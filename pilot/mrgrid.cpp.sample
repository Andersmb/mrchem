/** \mainpage The MRGrid program
 *
 * \author Stig Rune Jensen
 *
 * \version 1.0
 *
 * \par Copyright:
 * GPLv4
 *
 */

#include <boost/timer.hpp>
#include <Eigen/Core>

#include "parallel.h"
#include "constants.h"
#include "MREnv.h"
#include "TelePrompter.h"

#include "PeriodicTable.h"
#include "Atom.h"
#include "Molecule.h"
#include "MolecularGridGenerator.h"
#include "XCFunctional.h"
#include "XCProjector.h"

#include "BoundingBox.h"
#include "NodeIndex.h"
#include "MRGrid.h"
#include "FunctionTree.h"
#include "FunctionProjector.h"
#include "GridAdaptor.h"
#include "MWAdaptor.h"
#include "HilbertIterator.h"
#include "LebesgueIterator.h"
#include "MathUtils.h"

#include "Intgrl.h"
#include "DensExp.h"
#include "OrbExp.h"
#include "GaussExp.h"
#include "GaussFunc.h"


using namespace std;
using namespace Eigen;

void testAdaptiveGrid();
void testPureGrid();
void testTrees();
void testMPI();

int main(int argc, char **argv) {
    mpi::environment env(argc, argv);

    boost::timer rolex;
    rolex.restart();

    SET_PRINT_PRECISION(15);
    cout << scientific << setprecision(14);

    MREnv::initializeMRCPP();

    testMPI();
//    testAdaptiveGrid();
//    testPureGrid();
//    testTrees();

    MREnv::finalizeMRCPP(rolex.elapsed());

    return 0;
}

void testMPI() {
    // Constructing world box
    int n = -4;
    int l[3] = {0,0,0};
    int nb[3] = {1,1,1};
    double o[3] = {0.0,0.0,0.0};
    NodeIndex<3> idx(n, l);
    BoundingBox<3> world(idx, nb, o);
    println(0, world);

    // Setting up grid generator
    GridGenerator<3> generator(-1);

    // Constructing initial grid
    int k = 3;
    MRGrid<3> grid(world, k);
    generator.generateGrid(grid);
    grid.distributeNodes(3);
    grid.printNodeRankCount();

    // Setting up MW projection
    double prec = 1.0e-5;
    MWAdaptor<3> adaptor(prec);
    FunctionProjector<3> P(adaptor, -1);

    double alpha = 10.0;
    double coef = pow(alpha/pi, 3.0/2.0);
    double pos[3] = {8.0, 8.0, 8.0};
    GaussFunc<3> gFunc(alpha, coef, pos);

    FunctionTree<3> tree(grid);
    tree.printNodeRankCount();
    P(tree, gFunc);
    tree.printNodeRankCount();

    double int_1 = tree.integrate();
    double err_1 = tree.estimateError(false);
    println(0, endl);
    println(0, "Gaussian integral " << int_1);
    println(0, "Estimated error   " << err_1);
}

void testTrees() {
    //Setting up world parameters
    int k = 5;
    int type = Interpol;

    int n = -1;
    int l[3] = {0,-1,-2};
    int nb[3] = {1,2,4};
    double o[3] = {0.0,0.0,0.0};

    //Constructing world box
    NodeIndex<1> idx_1D(n, l);
    BoundingBox<1> world_1D(idx_1D, nb, o);

    //Constructing world box
    NodeIndex<2> idx_2D(n, l);
    BoundingBox<2> world_2D(idx_2D, nb, o);

    //Constructing world box
    NodeIndex<3> idx_3D(n, l);
    BoundingBox<3> world_3D(idx_3D, nb, o);
    println(0, world_3D);

    FunctionTree<1> *tree_1D = new FunctionTree<1>(world_1D, k, type);
    delete tree_1D;

    FunctionTree<2> *tree_2D = new FunctionTree<2>(world_2D, k, type);
    delete tree_2D;

    FunctionTree<3> *tree_3D = new FunctionTree<3>(world_3D, k, type);
    delete tree_3D;
}

void testAdaptiveGrid() {
    // Setting up molecular density expansion
    Molecule molecule("alkane_1.xyz");
    molecule.print();

    Intgrl intgrl("alkane_1.bas");
    MatrixXd D = MathUtils::readMatrixFile("alkane_1.dens");
    DensExp densExp(intgrl, D);

    GaussExp<3> gaussDens = densExp.getAODensExpansion();
    gaussDens.calcScreening(15);
    gaussDens.setScreen(true);

    // Constructing world box
    int n = -4;
    int l[3] = {-1,-1,-1};
    int nb[3] = {2,2,2};
    double o[3] = {0.0,0.0,0.0};
    NodeIndex<3> idx(n, l);
    BoundingBox<3> world(idx, nb, o);
    println(0, world);

    // Setting up grid generator
    MolecularGridGenerator generator;
    generator.setUniformScale(-3);
    generator.setDepth(3);
    generator.setWidth(0);
    generator.setNuclearDependence(0);

    // Constructing initial grid
    int k = 3;
    MRGrid<3> grid(world, k);
    generator.generateGrid(grid, molecule);
    println(0, grid);

    // Setting up adaptive MW projection
    bool absPrec = true;
    double thrs = 1.0e-4;
    GridAdaptor<3> adaptor(thrs, absPrec);
    FunctionProjector<3> P;

    XCFunctional xcFunc(false, 2);
    xcFunc.setFunctional("LDA");
    XCProjector P_en(xcFunc, 0);
    XCProjector P_pot(xcFunc, 1);
    XCProjector P_grad(xcFunc, 2);

    printout(0, " nNodes");
    printout(0, "    nQuad");
    printout(0, "         Charge");
    printout(0, "         Error");
    printout(0, "         XC Energy");
    printout(0, "        rho");
    printout(0, "       E_xc");
    printout(0, "     dE_xc");
    printout(0, "    ddE_xc");
    printout(0, endl);
    printout(0, endl);

    double maxError = 1.0;
    double charge = (double) molecule.getNElectrons();
    while (true) {
        FunctionTree<3> elDens(grid);
        FunctionTree<3> xcDens(grid);
        FunctionTree<3> xcPot(grid);
        FunctionTree<3> xcGrad(grid);

        P(elDens, gaussDens);
        P_en(xcDens, elDens);
        P_pot(xcPot, elDens);
        P_grad(xcGrad, elDens);

        double estErrorCharge = elDens.estimateError(absPrec);
        double estErrorEnergy = xcDens.estimateError(absPrec);
        double estErrorPotential = xcPot.estimateError(absPrec);
        double estErrorGradient = xcGrad.estimateError(absPrec);

        maxError = estErrorCharge;
        //maxError = max(maxError, estErrorEnergy);
        //maxError = max(maxError, estErrorPotential);
        //maxError = max(maxError, estErrorGradient);

        int nNodes = grid.getNEndNodes();
        int nQuad = pow(2*(k+1), 3);
        double numCharge = elDens.integrate();
        double numEnergy = xcDens.integrate();
        double realError = numCharge - charge;
        if (not absPrec) {
            realError *= 1.0/charge;
        }

        printout(0, setw(6) << nNodes);
        printout(0, setw(10) << nNodes*nQuad);
        SET_PRINT_PRECISION(10);
        printout(0, setw(20) << numCharge);
        SET_PRINT_PRECISION(1);
        printout(0, setw(10) << realError);
        SET_PRINT_PRECISION(10);
        printout(0, setw(20) << numEnergy);
        SET_PRINT_PRECISION(1);
        printout(0, setw(10) << estErrorCharge);
        printout(0, setw(10) << estErrorEnergy);
        printout(0, setw(10) << estErrorPotential);
        printout(0, setw(10) << estErrorGradient);
        printout(0, endl);

        if (maxError < thrs) {
            break;
        }

        adaptor.adaptGrid(grid, elDens);
        //adaptor.adaptGrid(grid, xcDens);
        //adaptor.adaptGrid(grid, xcPot);
        //adaptor.adaptGrid(grid, xcGrad);
    }
    println(0, grid);
}

void testPureGrid() {
    // Setting up molecular density expansion
    Molecule molecule("diamond_1.xyz");
    molecule.print();

    Intgrl intgrl("diamond_1.bas");
    MatrixXd D = MathUtils::readMatrixFile("diamond_1.dens");
    DensExp densExp(intgrl, D);

    GaussExp<3> gaussDens = densExp.getAODensExpansion();
    gaussDens.calcScreening(25);
    gaussDens.setScreen(true);

    // Setting up world parameters
    int n = -4;
    int l[3] = {-1,-1,-1};
    int nb[3] = {2,2,2};
    double o[3] = {0.0,0.0,0.0};
    NodeIndex<3> idx(n, l);

    // Constructing world box
    BoundingBox<3> world(idx, nb, o);
    println(0, world);

    // Setting up grid generator
    MolecularGridGenerator generator;
    generator.setUniformScale(-3);
    generator.setDepth(1);
    generator.setWidth(2);
    generator.setNuclearDependence(0);

    // Constructing initial grid
    int k = 3;
    MRGrid<3> grid(world, k);
    generator.generateGrid(grid, molecule);
    println(0, grid);

    //setting up quadrature data
    MatrixXd points;
    VectorXd weights;
    grid.getQuadPoints(points);
    grid.getQuadWeights(weights);

    int nPoints = weights.size();
    VectorXd values = VectorXd::Zero(weights.size());

    for (int n = 0; n < nPoints; n++) {
        double r[3] = { points(n,0), points(n,1), points(n,2) };
        values(n) = gaussDens.evalf(r);
    }

    bool absPrec = true;
    double charge = (double) molecule.getNElectrons();
    double quadCharge = weights.dot(values);
    double quadError = quadCharge - charge;
    if (not absPrec) {
        quadError *= 1.0/charge;
    }

    println(0, grid);
    println(0, "Quadrature points       " << points.rows() << " x " << points.cols());
    println(0, "Quadrature weights      " << weights.size());
    println(0, "Quadrature values       " << values.size() << endl);
    println(0, "Analytic charge         " << setw(25) << charge);
    println(0, "Integrated charge       " << setw(25) << quadCharge);
    println(0, "Integrated charge error " << setw(25) << quadError << endl);
}
