/** \mainpage The MRGrid program
 *
 * \author Stig Rune Jensen
 *
 * \version 1.0
 *
 * \par Copyright:
 * GPLv4
 *
 */

#include <boost/timer.hpp>
#include <Eigen/Core>

#include "parallel.h"
#include "constants.h"
#include "MREnv.h"
#include "TelePrompter.h"

#include "PeriodicTable.h"
#include "Atom.h"
#include "Molecule.h"
#include "MolecularGridGenerator.h"

#include "BoundingBox.h"
#include "NodeIndex.h"
#include "MRGrid.h"
#include "FunctionTree.h"
#include "MathUtils.h"

#include "Intgrl.h"
#include "DensExp.h"
#include "OrbExp.h"
#include "GaussExp.h"
#include "GaussFunc.h"


using namespace std;
using namespace Eigen;

void testGrid();
void testTrees();

int main(int argc, char **argv) {
    mpi::environment env(argc, argv);
    mpi::communicator world;
    int rank = world.rank();

    boost::timer delta;
    boost::timer rolex;
    rolex.restart();

    SET_PRINT_PRECISION(15);
    cout << scientific << setprecision(14);

    int k = 5;
    double prec = 1.0e-4;

    MREnv::initializeMRCPP(k, prec);

//    testGrid();
    testTrees();

    MREnv::finalizeMRCPP(rolex.elapsed());

    return 0;
}

void testTrees() {
    //Setting up world parameters
    int k = 5;
    int type = Interpol;

    int n = -1;
    int l[3] = {0,-1,-2};
    int nb[3] = {1,2,4};
    double o[3] = {0.0,0.0,0.0};

    //Constructing world box
    NodeIndex<1> idx_1D(n, l);
    BoundingBox<1> world_1D(idx_1D, nb, o);

    //Constructing world box
    NodeIndex<2> idx_2D(n, l);
    BoundingBox<2> world_2D(idx_2D, nb, o);

    //Constructing world box
    NodeIndex<3> idx_3D(n, l);
    BoundingBox<3> world_3D(idx_3D, nb, o);
    println(0, world_3D);

    FunctionTree<1> *tree_1D = new FunctionTree<1>(type, k, &world_1D);
    delete tree_1D;

    FunctionTree<2> *tree_2D = new FunctionTree<2>(type, k, &world_2D);
    delete tree_2D;

    FunctionTree<3> *tree_3D = new FunctionTree<3>(type, k, &world_3D);
    delete tree_3D;
}

void testGrid() {
    //Setting up world parameters
    int n = -3;
    int l[3] = {-1,-1,-1};
    int nb[3] = {2,2,2};
    double o[3] = {0.0,0.0,0.0};
    NodeIndex<3> idx(n, l);

    //Constructing world box
    BoundingBox<3> world(idx, nb, o);
    println(0, world);

    //Constructing initial grid
    int k = 5;
    MRGrid<3> grid(k, &world);
    println(0, grid);

    // Setting up molecular density
    Molecule molecule("diamond_1.xyz");
    molecule.print();

    Intgrl intgrl("diamond_1.bas");
    MatrixXd D = MathUtils::readMatrixFile("diamond_1.dens");
    DensExp densExp(intgrl, D);

    //Adapting grid to molecular geometry
    MolecularGridGenerator generator;
    generator.setUniformScale(-1);
    generator.setAmplitude(5);
    generator.setWidth(5);
    generator.setNuclearDependence(0);

    generator.generateGrid(grid, molecule);
    println(0, grid);

//    MWProjector P(grid);
//    P.setAbsPrec(1.0e-3);
//    P.setRelPrec(1.0e-6);
//    P.setUniformDepth(0);
//    P.setMaxRefinement(0);

    //setting up quadrature data
    MatrixXd points;
    VectorXd weights;
    grid.getQuadPoints(points);
    grid.getQuadWeights(weights);

    int nPoints = weights.size();
    VectorXd values = VectorXd::Zero(weights.size());

    GaussExp<3> density = densExp.getAODensExpansion();
    density.calcScreening(25);
    density.setScreen(true);
    for (int n = 0; n < nPoints; n++) {
        double r[3] = { points(n,0), points(n,1), points(n,2) };
        values(n) = density.evalf(r);
    }

    double integral = weights.dot(values);

    println(0, "Quadrature points  " << points.rows() << " x " << points.cols());
    println(0, "Quadrature weights " << weights.size());
    println(0, "Quadrature values  " << values.size() << endl);
    println(0, "Integrated charge  " << integral << endl);

}

