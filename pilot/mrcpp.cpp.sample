/** \mainpage The MRGrid program
 *
 * \author Stig Rune Jensen
 *
 * \version 1.0
 *
 * \par Copyright:
 * GPLv4
 *
 */

#include <boost/timer.hpp>
#include <Eigen/Core>

#include "parallel.h"
#include "constants.h"
#include "MREnv.h"
#include "TelePrompter.h"
#include "MathUtils.h"

#include "BoundingBox.h"
#include "NodeIndex.h"
#include "MultiResolutionAnalysis.h"
#include "InterpolatingBasis.h"
#include "FunctionTree.h"
#include "FunctionTree_S.h"
#include "MWProjector.h"
#include "GridGenerator.h"
#include "WaveletAdaptor.h"

#include "GaussFunc.h"


using namespace std;
using namespace Eigen;

void testTrees();
void testProjection();

int main(int argc, char **argv) {
    mpi::environment env(argc, argv);

    boost::timer rolex;
    rolex.restart();

    SET_PRINT_PRECISION(15);
    cout << scientific << setprecision(14);

    MREnv::initializeMRCPP();

    testTrees();
    //testProjection();

    MREnv::finalizeMRCPP(rolex.elapsed());

    return 0;
}

void testTrees() {
    //Setting up world parameters
    int n = -1;
    int l[3] = {0,-1,-2};
    int nb[3] = {1,2,4};

    //Setting up scaling basis
    int k = 5;
    InterpolatingBasis basis(k);

    {   //Testing 1D
        //NodeIndex<1> idx(n, l);
        //BoundingBox<1> world(idx, nb);
        //MultiResolutionAnalysis<1> MRA(world, basis);
        //GridGenerator<1> G(MRA);
        //FunctionTree<1> *tree = G();
        //delete tree;
    }

    {   //Testing 2D
        //NodeIndex<2> idx(n, l);
        //BoundingBox<2> world(idx, nb);
        //MultiResolutionAnalysis<2> MRA(world, basis);
        //GridGenerator<2> G(MRA);
        //FunctionTree<2> *tree = G();
        //delete tree;
    }

    
    {   //Testing 3D
        NodeIndex<3> idx(n, l);
        BoundingBox<3> world(idx, nb);
        MultiResolutionAnalysis<3> MRA(world, basis);
        GridGenerator<3> G(MRA);
        FunctionTree<3> *tree = G();
        tree->setZero();
        delete tree;
    }
}


void testProjection() {
    // Constructing world box
    int n = -4;
    int l[3] = {-1,-1,-1};
    int nb[3] = {2,2,2};
    NodeIndex<3> idx(n, l);
    BoundingBox<3> world(idx, nb);

    // Initializing MRA
    int k = 5;
    InterpolatingBasis basis(k);
    MultiResolutionAnalysis<3> MRA(world, basis);

    // Constructing analytic function
    double beta = 20.0;
    double alpha = pow(beta/pi, 3.0/2.0);
    double pos[3] = {0.0, 0.0, 0.0};
    int pow[3] = {0, 0, 0};
    GaussFunc<3> f_func(beta, alpha, pos, pow);

    // Setting up adaptor
    double prec = 1.0e-3;
    WaveletAdaptor<3> w_adaptor(prec);

    // Setting up projector
    MWProjector<3> Q(MRA, w_adaptor);
    FunctionTree<3> *f_tree = Q(f_func);

    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();

    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    delete f_tree;
}

    // Initializing tree
    //FunctionTree<3> f_tree(MRA);
    //FunctionTree_S<3> f_tree_s(MRA, 1024);
    //FunctionTree<3> &f_tree = f_tree_s.getTree();

