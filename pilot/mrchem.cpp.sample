/** \mainpage The MRCPP program
 *
 * \author Stig Rune Jensen
 *
 * \version 1.0
 *
 * \par Copyright:
 * GPLv4
 *
 */

#include <Eigen/Core>

#include "parallel.h"
#include "constants.h"
#include "MREnv.h"
#include "TelePrompter.h"
#include "Timer.h"
#include "MathUtils.h"

#include "BoundingBox.h"
#include "NodeIndex.h"
#include "MultiResolutionAnalysis.h"
#include "InterpolatingBasis.h"
#include "FunctionTree.h"
#include "MWProjector.h"
#include "MWAdder.h"
#include "MWMultiplier.h"
#include "PoissonOperator.h"
#include "GridGenerator.h"
#include "GridCleaner.h"

#include "GaussFunc.h"
#include "GaussExp.h"


using namespace std;
using namespace Eigen;

void testZeroTree();
void testProjection();
void testPoisson();
void testAddition();
void testMultiplication();
void testGridGenerator();
void testTreeCleaner();

template<int D> MultiResolutionAnalysis<D>* initializeMRA(int order);
template<int D> GaussFunc<D>* initializeGauss();
GaussExp<3>* initializeGaussExp(int N);

int main(int argc, char **argv) {
    mpi::environment env(argc, argv);

    Timer rolex;
    rolex.restart();

    int printlevel = 10;
    int printprec = 15;
    bool teletype = false;
    MREnv::initializeMRCPP(printlevel, printprec, teletype);

    //testZeroTree();
    //testProjection();
    //testGridGenerator();
    //testTreeCleaner();
    //testAddition();
    //testMultiplication();
    testPoisson();

    MREnv::finalizeMRCPP(rolex);

    return 0;
}

template<int D>
MultiResolutionAnalysis<D>* initializeMRA(int order) {
    // Constructing world box
    int n = -4;
    int l[3] = {-1,-1,-1};
    int nb[3] = {2,2,2};
    NodeIndex<D> idx(n, l);
    BoundingBox<D> world(idx, nb);

    // Constructing scaling basis
    InterpolatingBasis basis(order);

    // Initializing MRA
    return new MultiResolutionAnalysis<D>(world, basis);
}

template<int D>
GaussFunc<D>* initializeGauss() {
    // Constructing analytic function
    double beta = 1.0e1;
    double alpha = pow(beta/pi, D/2.0);
    double pos[3] = {0.0, 0.0, 0.0};
    int pow[3] = {0, 0, 0};
    return new GaussFunc<D>(beta, alpha, pos, pow);
}

GaussExp<3>* initializeGaussExp(int N) {
    // Constructing analytic function
    GaussExp<3> *gExp = new GaussExp<3>();
    double h = 32.0/(N+1);
    double r0 = 16.0;
    double beta = 0.1;
    for (int i = 1; i <= N; i++) {
        for (int j = 1; j <= N; j++) {
            for (int k = 1; k <= N; k++) {
                double alpha = pow(beta/pi, 3/2.0);
                double pos[3] = {r0+i*h , r0+j*h, r0+k*h};
                GaussFunc<3> gFunc(beta, alpha, pos);
                gExp->append(gFunc);
            }
            beta *= 2.0;
        }
    }
    //gExp->calcScreening(25.0);
    return gExp;
}

void testZeroTree() {
    println(0, "\n\n========= Testing default ==========\n");
    println(0, "\n1D\n");
    {
        MultiResolutionAnalysis<1> *MRA = initializeMRA<1>(2);
        GridGenerator<1> G(*MRA);
        FunctionTree<1> *tree = G();
        tree->setZero();

        double integral = tree->integrate();
        double sq_norm = tree->getSquareNorm();
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);

        delete tree;
        delete MRA;
    }
    println(0, "\n2D\n");
    {
        MultiResolutionAnalysis<2> *MRA = initializeMRA<2>(3);
        GridGenerator<2> G(*MRA);
        FunctionTree<2> *tree = G();
        tree->setZero();

        double integral = tree->integrate();
        double sq_norm = tree->getSquareNorm();
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);

        delete tree;
        delete MRA;
    }
    println(0, "\n3D\n");
    {
        MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(4);
        GridGenerator<3> G(*MRA);
        FunctionTree<3> *tree = G();
        tree->setZero();

        double integral = tree->integrate();
        double sq_norm = tree->getSquareNorm();
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);

        delete tree;
        delete MRA;
    }
    println(0, "\n\n====================================\n\n");
}

void testProjection() {
    int order = 9;
    double prec = 1.0e-6;

    println(0, "\n\n======== Testing MWProjector =======\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(order);
    GaussExp<3> *f_func = initializeGaussExp(3);

    // Setting up adaptor and projector
    MWProjector<3> Q(*MRA, prec);
    GridGenerator<3> G(*MRA);

    println(0, "\n\nProjecting function adaptively\n");
    FunctionTree<3> *f_tree = G(*f_func);
    //f_tree->setZero();
    Q(*f_tree, *f_func);

    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral        " << integral);
    println(0, "Square norm     " << sq_norm);

    delete f_tree;
    delete f_func;
    delete MRA;
    println(0, "\n\n====================================\n\n");
}

void testGridGenerator() {
    println(0, "\n\n======= Testing GridGenerator ======\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);
    GaussFunc<3> *f_func = initializeGauss<3>();

    double prec = 1.0e-3;
    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA);
    MWProjector<3> Q_adap(*MRA, prec);

    FunctionTree<3> *f_tree = 0;
    FunctionTree<3> *g_tree = 0;
    FunctionTree<3> *h_tree = 0;

    {
        println(0, "\n\nAdapting analytic function\n");
        f_tree = G(*f_func);
        println(0, "\n\nSetting function to zero");
        f_tree->setZero();

        double integral = f_tree->integrate();
        double sq_norm = f_tree->getSquareNorm();
        println(0, endl);
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);
    }
    println(0, "\n\n------------------------------------");
    {
        println(0, "\n\nAdapting grid\n");
        g_tree = G(*f_tree);
        println(0, "\n\nProjecting function\n");
        Q(*g_tree, *f_func);

        double integral = g_tree->integrate();
        double sq_norm = g_tree->getSquareNorm();
        println(0, endl);
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);
    }
    println(0, "\n\n------------------------------------");
    {
        println(0, "\n\nCopying grid\n");
        h_tree = G();
        G(*h_tree, *g_tree);
        println(0, "\n\nProjecting function adaptively\n");
        Q_adap(*h_tree, *f_func);

        double integral = h_tree->integrate();
        double sq_norm = h_tree->getSquareNorm();
        println(0, endl);
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);
    }

    if (h_tree != 0) delete h_tree;
    if (g_tree != 0) delete g_tree;
    if (f_tree != 0) delete f_tree;
    if (f_func != 0) delete f_func;
    if (MRA != 0) delete MRA;
    println(0, "\n\n====================================\n\n");
}

void testTreeCleaner() {
    println(0, "\n\n======== Testing TreeCleaner =======\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);
    GaussExp<3> *f_func = initializeGaussExp(5);

    double prec = 1.0e-3;

    MWProjector<3> Q(*MRA);
    MWProjector<3> Q_adap(*MRA, prec);
    GridCleaner<3> C(*MRA, prec);
    GridGenerator<3> G(*MRA);

    FunctionTree<3> *f_tree = G(*f_func);

    int n_nodes = 1;
    while (n_nodes > 0) {
        Q(*f_tree, *f_func);
        n_nodes = C(*f_tree);
    }
    Q(*f_tree, *f_func);
    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    FunctionTree<3> *g_tree = G(*f_func);
    Q_adap(*g_tree, *f_func);
    double int_adap = g_tree->integrate();
    double norm_adap = g_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << int_adap);
    println(0, "Square norm  " << norm_adap);

    delete g_tree;
    delete f_tree;
    delete f_func;
    delete MRA;
    println(0, "\n\n====================================\n\n");
}

void testAddition() {
    println(0, "\n\nTesting MWAdder\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(9);

    double prec = 1.0e-6;

    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA, prec);
    MWAdder<3> add(*MRA);

    GaussExp<3> *f_func = initializeGaussExp(2);
    GaussExp<3> *g_func = initializeGaussExp(3);

    FunctionTree<3> *f_tree = G(*f_func);
    FunctionTree<3> *g_tree = G(*g_func);
    
    Q(*f_tree, *f_func);
    Q(*g_tree, *g_func);

    FunctionTree<3> *h_tree = G();
    G(*h_tree, *f_tree);
    G(*h_tree, *g_tree);

    FunctionTreeVector<3> sum_vec;
    sum_vec.push_back(1.0, *f_tree);
    sum_vec.push_back(-2.0, *g_tree);

    add(*h_tree, sum_vec);

    double integral = h_tree->integrate();
    double sq_norm = h_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral            " << setw(40) << integral);
    println(0, "Square norm         " << setw(40) << sq_norm);

    delete f_tree;
    delete g_tree;
    delete h_tree;
    delete f_func;
    delete g_func;
    delete MRA;
}

void testMultiplication() {
    println(0, "\n\nTesting MWMultiplier\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(9);

    double prec = 1.0e-6;

    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA, prec);
    MWMultiplier<3> mult(*MRA, prec);

    GaussExp<3> *f_func = initializeGaussExp(2);
    GaussExp<3> *g_func = initializeGaussExp(3);

    FunctionTree<3> *f_tree = G(*f_func);
    FunctionTree<3> *g_tree = G(*g_func);

    Q(*f_tree, *f_func);
    Q(*g_tree, *g_func);

    FunctionTreeVector<3> prod_vec;
    prod_vec.push_back(1.0, *f_tree);
    prod_vec.push_back(2.0, *g_tree);
    FunctionTree<3> *h_tree = mult(prod_vec);

    double integral = h_tree->integrate();
    double sq_norm = h_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    delete f_tree;
    delete g_tree;
    delete h_tree;
    delete f_func;
    delete g_func;
    delete MRA;
}

void testPoisson() {
    Timer analy_t, proj_t, build_t, apply_t;
    println(0, "\n\nTesting Poisson operator\n");

    // Computational domain [0,32]
    int n = -6;
    NodeIndex<3> idx(n);
    BoundingBox<3> world(idx);

    // Constructing scaling basis
    int k = 7;
    InterpolatingBasis basis(k);

    // Initializing MRA
    MultiResolutionAnalysis<3> MRA(world, basis);

    double proj_prec = 1.0e-4;
    double apply_prec = 1.0e-4;
    double build_prec = 1.0e-4;

    GridGenerator<3> G(MRA);
    MWProjector<3> Q(MRA, proj_prec);

    double alpha = 100.0;
    double coef = pow(alpha/pi, 3.0/2.0);
    double pos[3] = {pi,pi,pi};
    int pow[3] = {0,0,0};
    GaussFunc<3> f_func(alpha, coef, pos, pow);

    printout(0, endl);
    println(0, "================= Computing analytic energy ================");
    printout(0, endl);

    analy_t.restart();
    double analyticEnergy = f_func.calcCoulombEnergy(f_func);
    analy_t.stop();

    println(0, "Time analytic:      " << analy_t << endl);
    println(0, "============================================================");
    printout(0, endl);



    printout(0, endl);
    println(0, "=================== Projecting function ====================");
    printout(0, endl);

    proj_t.restart();
    FunctionTree<3> *f_tree = Q(f_func);
    proj_t.stop();

    println(0, "Time projection:    " << proj_t << endl);
    println(0, "============================================================");
    printout(0, endl);



    printout(0, endl);
    println(0, "================== Constructing operator ===================");
    printout(0, endl);

    build_t.restart();
    PoissonOperator P(MRA, apply_prec, build_prec);
    build_t.stop();

    println(0, "Time construction:  " << build_t << endl);
    println(0, "============================================================");
    printout(0, endl);



    printout(0, endl);
    println(0, "==================== Applying operator =====================");
    printout(0, endl);

    apply_t.restart();
    FunctionTree<3> *g_tree = G();
    P(*g_tree, *f_tree);
    apply_t.stop();

    println(0, "Time application:   " << apply_t << endl);
    println(0, "============================================================");
    printout(0, endl);



    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    println(0, *f_tree);
    println(0, *g_tree);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    double fInt = f_tree->integrate();
    double fNorm = sqrt(f_tree->getSquareNorm());
    double gInt = g_tree->integrate();
    double gNorm = sqrt(g_tree->getSquareNorm());
    double numericalEnergy = g_tree->dot(*f_tree);
    double error = (numericalEnergy-analyticEnergy)/numericalEnergy;

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    println(0, "f_func integral:              " << setw(30) << fInt);
    println(0, "f_func norm:                  " << setw(30) << fNorm << endl);
    println(0, "g_func integral:              " << setw(30) << gInt);
    println(0, "g_func norm:                  " << setw(30) << gNorm << endl);
    println(0, "Analytic energy:              " << setw(30) << analyticEnergy);
    println(0, "Numerical energy:             " << setw(30) << numericalEnergy);
    println(0, "Relative error:               " << setw(30) << error);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    println(0, "Time analytic:      " << analy_t);
    println(0, "Time projection:    " << proj_t);
    println(0, "Time construction:  " << build_t);
    println(0, "Time application:   " << apply_t);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    delete f_tree;
    delete g_tree;
}

