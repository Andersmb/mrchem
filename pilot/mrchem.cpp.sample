/** \mainpage The MRCPP program
 *
 * \author Stig Rune Jensen
 *
 * \version 1.0
 *
 * \par Copyright:
 * GPLv4
 *
 */

#include <Eigen/Core>

#include "mrchem.h"
#include "parallel.h"
#include "constants.h"
#include "MREnv.h"
#include "Timer.h"
#include "TelePrompter.h"
#include "MathUtils.h"
#include "Plot.h"

#include "AnalyticFunction.h"
#include "BoundingBox.h"
#include "NodeIndex.h"
#include "MultiResolutionAnalysis.h"
#include "InterpolatingBasis.h"
#include "FunctionTree.h"
#include "DerivativeOperator.h"
#include "PoissonOperator.h"
#include "HelmholtzOperator.h"
#include "MWProjector.h"
#include "MWAdder.h"
#include "MWMultiplier.h"
#include "GridGenerator.h"
#include "GridCleaner.h"
#include "CopyAdaptor.h"
#include "WaveletAdaptor.h"

#include "PeriodicTable.h"
#include "Molecule.h"
#include "Nucleus.h"
#include "MolPlot.h"

#include "GaussFunc.h"
#include "HydrogenicFunction.h"
#include "NuclearFunction.h"


using namespace std;
using namespace Eigen;

void testAnalyticFunction();
void testProjection();
void testGridGenerator();
void testTreeCleaner();
void testAddition();
void testMultiplication();
void testPoisson();
void testDerivative();
void testSCF();

Getkw Input;

template<int D> MultiResolutionAnalysis<D>* initializeMRA();
template<int D> GaussFunc<D>* initializeGauss(const double *pos = 0);

int main(int argc, char **argv) {
    mpi::environment env(argc, argv);

    Timer rolex;
    rolex.restart();

    MREnv::initializeMRCPP(argc, argv);

    bool run_projection = Input.get<bool>("Pilot.run_projection");
    bool run_addition = Input.get<bool>("Pilot.run_addition");
    bool run_multiplication = Input.get<bool>("Pilot.run_multiplication");
    bool run_poisson = Input.get<bool>("Pilot.run_poisson");
    bool run_derivative = Input.get<bool>("Pilot.run_derivative");
    bool run_scf = Input.get<bool>("Pilot.run_scf");
    bool run_molecule = Input.get<bool>("Pilot.run_molecule");

    if (run_projection) testProjection();
    if (run_addition) testAddition();
    if (run_multiplication) testMultiplication();
    if (run_derivative) testDerivative();
    if (run_poisson) testPoisson();
    if (run_scf) testSCF();

    MREnv::finalizeMRCPP(rolex);

    return 0;
}

template<int D>
MultiResolutionAnalysis<D>* initializeMRA() {
    // Constructing world box
    int scale = Input.get<int>("World.scale");
    vector<int> corner = Input.getIntVec("World.corner");
    vector<int> boxes = Input.getIntVec("World.boxes");
    NodeIndex<D> idx(scale, corner.data());
    BoundingBox<D> world(idx, boxes.data());

    // Constructing scaling basis
    int order = Input.get<int>("order");
    InterpolatingBasis basis(order);

    // Initializing MRA
    return new MultiResolutionAnalysis<D>(world, basis);
}

template<int D>
GaussFunc<D>* initializeGauss(const double *pos) {
    // Constructing analytic function
    double beta = 20.0;
    double alpha = pow(beta/pi, D/2.0);
    int pow[3] = {0, 0, 0};
    if (pos != 0) {
        return new GaussFunc<D>(beta, alpha, pos, pow);
    } else {
        double o[3] = {0.0, 0.0, 0.0};
        return new GaussFunc<D>(beta, alpha, o, pow);
    }
}

void testProjection() {
    Timer timer;
    timer.restart();
    TelePrompter::printHeader(0, "Testing MWProjector");

    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>();

    double prec = Input.get<double>("rel_prec");
    MWProjector<3> Q(*MRA, prec);

    auto f = [] (const double *r) -> double {
        const double beta = 100.0;
        const double alpha = pow(beta/pi, 3.0/2.0);;
        const double r_0[3] = {0.0, 0.0, 0.0};
        double R = MathUtils::calcDistance(3, r, r_0);
        return alpha*exp(-beta*R*R);
    };

    FunctionTree<3> *f_tree = Q(f);

    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();

    println(0, " Integral                    " << setw(30) << integral);
    println(0, " Square norm                 " << setw(30) << sq_norm);

    delete f_tree;
    delete MRA;
    TelePrompter::printFooter(0, timer, 2);
}

void testAddition() {
    Timer timer;
    timer.restart();
    TelePrompter::printHeader(0, "Testing MWAdder");

    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>();

    double prec = Input.get<double>("rel_prec");
    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA, prec);
    MWAdder<3> add(*MRA, prec);

    double f_pos[3] = {0.0, 0.0,  0.1};
    double g_pos[3] = {0.0, 0.0, -0.1};
    GaussFunc<3> *f_func = initializeGauss<3>(f_pos);
    GaussFunc<3> *g_func = initializeGauss<3>(g_pos);

    FunctionTree<3> *f_tree = Q(*f_func);
    FunctionTree<3> *g_tree = Q(*g_func);
    FunctionTree<3> *h_tree = add(1.0, *f_tree, -2.0, *g_tree);

    double integral = h_tree->integrate();
    double sq_norm = h_tree->getSquareNorm();

    println(0, " Integral                    " << setw(30) << integral);
    println(0, " Square norm                 " << setw(30) << sq_norm);

    delete f_tree;
    delete g_tree;
    delete h_tree;
    delete f_func;
    delete g_func;
    delete MRA;
    TelePrompter::printFooter(0, timer, 2);
}

void testMultiplication() {
    Timer timer;
    timer.restart();
    TelePrompter::printHeader(0, "Testing MWMultiplier");

    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>();

    double prec = Input.get<double>("rel_prec");
    MWProjector<3> Q(*MRA, prec);
    MWMultiplier<3> mult(*MRA, prec);

    double f_pos[3] = {0.0, 0.0,  0.1};
    double g_pos[3] = {0.0, 0.0, -0.1};
    GaussFunc<3> *f_func = initializeGauss<3>(f_pos);
    GaussFunc<3> *g_func = initializeGauss<3>(g_pos);

    FunctionTree<3> *f_tree = Q(*f_func);
    FunctionTree<3> *g_tree = Q(*g_func);
    FunctionTree<3> *h_tree = mult(1.0, *f_tree, *g_tree);

    double integral = h_tree->integrate();
    double sq_norm = h_tree->getSquareNorm();

    println(0, " Integral                    " << setw(30) << integral);
    println(0, " Square norm                 " << setw(30) << sq_norm);

    delete f_tree;
    delete g_tree;
    delete h_tree;
    delete f_func;
    delete g_func;
    delete MRA;
}

void testDerivative() {
    Timer proj_t1, proj_t2, apply_t, add_t, tot_t;
    tot_t.restart();
    TelePrompter::printHeader(0, "Testing derivative operator");
    printout(0, endl);

    MultiResolutionAnalysis<1> *MRA = initializeMRA<1>();

    double prec = Input.get<double>("rel_prec");
    double proj_prec = prec/10.0;
    double apply_prec = prec;

    MWAdder<1> add(*MRA);
    MWProjector<1> Q(*MRA, proj_prec);
    GridGenerator<1> G(*MRA);
    DerivativeOperator<1> D_x(*MRA, 0.0, 0.0);

    auto f = [] (const double *r) -> double {
        const double alpha = 3.0;
        const double r_0[3] = {pi, pi, pi};
        double R = MathUtils::calcDistance(1, r, r_0);
        return exp(-alpha*R);
    };
    auto df = [] (const double *r) -> double {
        const double alpha = 3.0;
        const double r_0[3] = {pi, pi, pi};
        double R = MathUtils::calcDistance(1, r, r_0);
        double sign = 1.0;
        if (r[0] > r_0[0]) sign = -1.0;
        return sign*alpha*exp(-alpha*R);
    };

    proj_t1.restart();
    FunctionTree<1> *f_tree = Q(f);
    proj_t1.stop();
    println(0, " Projecting f      " << proj_t1);

    proj_t2.restart();
    FunctionTree<1> *df_tree = Q(df);
    proj_t2.stop();
    println(0, " Projecting df     " << proj_t2);

    apply_t.restart();
    FunctionTree<1> *dg_tree = G(*f_tree);  // Copy grid from f_tree
    D_x(*dg_tree, *f_tree, 0);              // Does not refine grid further
    apply_t.stop();
    println(0, " Applying D_x      " << apply_t);

    add_t.restart();
    FunctionTree<1> *err_tree = add(1.0, *df_tree, -1.0, *dg_tree);
    add_t.stop();
    println(0, " Computing error   " << add_t << endl);

    double f_int = f_tree->integrate();
    double f_norm = sqrt(f_tree->getSquareNorm());
    double df_int = df_tree->integrate();
    double df_norm = sqrt(df_tree->getSquareNorm());
    double dg_int = dg_tree->integrate();
    double dg_norm = sqrt(dg_tree->getSquareNorm());
    double abs_err = sqrt(err_tree->getSquareNorm());
    double rel_err = abs_err/df_norm;

    TelePrompter::printSeparator(0, '-', 1);
    println(0," f_tree integral:            " << setw(30) << f_int);
    println(0," f_tree norm:                " << setw(30) << f_norm << endl);
    println(0," df_tree integral:           " << setw(30) << df_int);
    println(0," df_tree norm:               " << setw(30) << df_norm << endl);
    println(0," dg_tree integral:           " << setw(30) << dg_int);
    println(0," dg_tree norm:               " << setw(30) << dg_norm << endl);
    println(0," absolute error:             " << setw(30) << abs_err);
    println(0," relative error:             " << setw(30) << rel_err << endl);

    delete f_tree;
    delete df_tree;
    delete dg_tree;
    delete err_tree;
    delete MRA;
    TelePrompter::printFooter(0, tot_t, 2);
}

void testPoisson() {
    Timer analy_t, proj_t, build_t, apply_t, tot_t;
    tot_t.restart();
    TelePrompter::printHeader(0, "Testing Poisson operator");
    printout(0, endl);

    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>();

    double prec = Input.get<double>("rel_prec");
    double proj_prec = prec/10.0;
    double build_prec = prec/10.0;
    double apply_prec = prec;

    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA, proj_prec);

    double beta = 100.0;
    double alpha = pow(beta/pi, 3.0/2.0);
    double pos[3] = {pi/3.0,pi/3.0,pi/3.0};
    GaussFunc<3> f_func(beta, alpha, pos);

    TelePrompter::printHeader(0, "Computing analytic energy");
    analy_t.restart();
    double ana_energy = f_func.calcCoulombEnergy(f_func);
    analy_t.stop();
    TelePrompter::printFooter(0, analy_t, 2);

    TelePrompter::printHeader(0, "Projecting function");
    proj_t.restart();
    FunctionTree<3> *f_tree = G(f_func);
    Q(*f_tree, f_func);
    proj_t.stop();
    TelePrompter::printFooter(0, proj_t, 2);

    TelePrompter::printHeader(0, "Constructing Poisson operator");
    build_t.restart();
    PoissonOperator P(*MRA, apply_prec, build_prec);
    build_t.stop();
    TelePrompter::printFooter(0, build_t, 2);

    TelePrompter::printHeader(0, "Applying Poisson operator");
    apply_t.restart();
    FunctionTree<3> *g_tree = G();
    P(*g_tree, *f_tree);
    apply_t.stop();
    TelePrompter::printFooter(0, apply_t, 2);

    double f_int = f_tree->integrate();
    double f_norm = sqrt(f_tree->getSquareNorm());
    double g_int = g_tree->integrate();
    double g_norm = sqrt(g_tree->getSquareNorm());
    double num_energy = g_tree->dot(*f_tree);
    double error = (num_energy-ana_energy)/num_energy;

    println(0, endl);
    println(0," f_tree integral:            " << setw(30) << f_int);
    println(0," f_tree norm:                " << setw(30) << f_norm << endl);
    println(0," g_tree integral:            " << setw(30) << g_int);
    println(0," g_tree norm:                " << setw(30) << g_norm << endl);
    println(0," Analytic energy:            " << setw(30) << ana_energy);
    println(0," Numerical energy:           " << setw(30) << num_energy);
    println(0," Relative error:             " << setw(30) << error << endl);
    println(0, endl);

    delete f_tree;
    delete g_tree;
    delete MRA;
    TelePrompter::printFooter(0, tot_t, 2);
}

void testSCF() {
    Timer analy_t, nuc_t, init_t;
    int order = 5;
    double prec = 1.0e-3;

    double proj_prec = prec;
    double apply_prec = prec;
    double build_prec = prec/10.0;
    double scf_prec = prec*10.0;

    // Computational domain [-32.0, 32.0]
    int scale = -5;
    int corner[3] = {-1, -1, -1};
    int nbox[3] = {2, 2, 2};
    NodeIndex<3> idx(scale, corner);
    BoundingBox<3> box(idx, nbox);

    InterpolatingBasis basis(order);
    MultiResolutionAnalysis<3> MRA(box, basis);

    FunctionTreeVector<3> tree_vec;
    MWAdder<3> add(MRA);
    MWMultiplier<3> mult(MRA, proj_prec);
    MWProjector<3> Q(MRA, proj_prec);
    GridGenerator<3> G(MRA);

    // Analytic solution
    int n = 1;                  // Principal quantum number
    int l = 0;                  // Angular quantum number
    int m_l = 0;                // Magnetic quantum number
    double Z = 1.0;             // Nuclear charge
    double E = -Z/(2.0*n*n);    // Total energy
    double pos[3] = {0.0, 0.0, 0.0};

    FunctionTree<3> *Vphi = 0;
    FunctionTree<3> *d_phi_n = 0;
    FunctionTree<3> *phi_np1 = 0;
    FunctionTree<3> *phi_n = 0;

    printout(0, endl);
    println(0, "================ Projecting analytic solution ==============");
    printout(0, endl);
    analy_t.restart();
    HydrogenicFunction hFunc(n, l, m_l, Z, pos);
    FunctionTree<3> *psi = Q(hFunc);
    analy_t.stop();
    println(0, "Time analytic:      " << analy_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "================ Projecting nuclear potential ==============");
    printout(0, endl);
    nuc_t.restart();
    //NuclearFunction nucFunc;
    //nucFunc.addNucleus(pos, Z, 1.0e-6);
    FunctionTree<3> *V = G();//Q(nucFunc);
    nuc_t.stop();
    println(0, "Time nuc pot:       " << nuc_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "================== Projecting initial guess ================");
    printout(0, endl);
    init_t.restart();
    GaussFunc<3> g_func(10.0, 1.0, pos);
    phi_n = Q(g_func);
    phi_n->normalize();
    init_t.stop();
    println(0, "Time initial guess: " << init_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    double eps_n = -0.5;
    double eps_np1 = 0.0;
    double d_eps_n = 0.0;

    TelePrompter::setPrecision(5);

    printout(0, endl);
    println(0, "======================== Running SCF =======================");
    printout(0, endl);

    printout(0, endl);
    printout(0, "Iter");
    printout(0, "      E_np1          dE_n   ");
    printout(0, "   ||phi_np1||    ||dPhi_n||");
    printout(0, endl << endl);

    int iter = 1;
    double residual = 1.0;
    vector<Timer> scf_t;
    while (residual > scf_prec) {
        Timer cycle_t;
        cycle_t.restart();
        if (eps_n > 0.0) eps_n *= -1.0;
        double mu_n = sqrt(-2*eps_n);
        HelmholtzOperator H(MRA, mu_n, apply_prec, build_prec);

        tree_vec.push_back(V);
        tree_vec.push_back(phi_n);
        Vphi = G(tree_vec);
        mult(*Vphi, tree_vec, 1);
        tree_vec.clear();

        phi_np1 = G();
        H(*phi_np1, *Vphi);
        *phi_np1 *= -1.0/(2.0*pi);
        delete Vphi;

        tree_vec.push_back(1.0, phi_np1);
        tree_vec.push_back(-1.0, phi_n);
        d_phi_n = add(tree_vec);
        tree_vec.clear();

        tree_vec.push_back(V);
        tree_vec.push_back(phi_np1);
        Vphi = G(tree_vec);
        mult(*Vphi, tree_vec, 1);
        tree_vec.clear();

        double norm = sqrt(phi_np1->getSquareNorm());
        residual = sqrt(d_phi_n->getSquareNorm());
        d_eps_n = d_phi_n->dot(*Vphi)/(norm*norm);
        eps_np1 = eps_n + d_eps_n;
        delete Vphi;

        printout(0, setw(4) << iter);
        printout(0, setw(14) << eps_np1);
        printout(0, setw(14) << d_eps_n);
        printout(0, setw(14) << norm);
        printout(0, setw(14) << residual);
        printout(0, endl);

        delete d_phi_n;
        delete phi_n;

        eps_n = eps_np1;
        phi_n = phi_np1;
        phi_n->normalize();

        cycle_t.stop();
        scf_t.push_back(cycle_t);
        iter++;
    }
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "======================== SCF timings =======================");
    printout(0, endl);
    for (int i = 0; i < scf_t.size(); i++) {
        println(0, "Time SCF cycle:     " << scf_t[i]);
    }
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    tree_vec.push_back(1.0, phi_n);
    tree_vec.push_back(-1.0, psi);
    d_phi_n = add(tree_vec);
    tree_vec.clear();

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    double error = sqrt(d_phi_n->getSquareNorm());
    println(0, "Final energy   " << setw(20) << eps_n    << setw(20) << (E - eps_n));
    println(0, "Final residual " << setw(20) << residual << setw(20) << error);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    delete d_phi_n;
    delete phi_n;
    delete psi;
    delete V;
}

void testGridGenerator() {
    Timer timer;
    timer.restart();
    TelePrompter::printHeader(0, "Testing GridGenerator");

    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>();
    GaussFunc<3> *f_func = initializeGauss<3>();

    double prec = Input.get<double>("rel_prec");
    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA);
    MWProjector<3> Q_adap(*MRA, prec);

    FunctionTree<3> *f_tree = 0;
    FunctionTree<3> *g_tree = 0;
    FunctionTree<3> *h_tree = 0;

    {
        println(0, "\n\nAdapting analytic function\n");
        f_tree = G(*f_func);
        println(0, "\n\nSetting function to zero");
        f_tree->setZero();

        double integral = f_tree->integrate();
        double sq_norm = f_tree->getSquareNorm();
        println(0, " Integral                    " << setw(30) << integral);
        println(0, " Square norm                 " << setw(30) << sq_norm);
    }
    TelePrompter::printSeparator(0, '-');
    {
        println(0, "\n\nAdapting grid\n");
        g_tree = G(*f_tree);
        println(0, "\n\nProjecting function\n");
        Q(*g_tree, *f_func);

        double integral = g_tree->integrate();
        double sq_norm = g_tree->getSquareNorm();
        println(0, endl);
        println(0, " Integral                    " << setw(30) << integral);
        println(0, " Square norm                 " << setw(30) << sq_norm);
    }
    TelePrompter::printSeparator(0, '-');
    {
        println(0, "\n\nCopying grid\n");
        h_tree = G();
        G(*h_tree, *g_tree);
        println(0, "\n\nProjecting function adaptively\n");
        Q_adap(*h_tree, *f_func);

        double integral = h_tree->integrate();
        double sq_norm = h_tree->getSquareNorm();
        println(0, endl);
        println(0, " Integral                    " << setw(30) << integral);
        println(0, " Square norm                 " << setw(30) << sq_norm);
    }

    if (h_tree != 0) delete h_tree;
    if (g_tree != 0) delete g_tree;
    if (f_tree != 0) delete f_tree;
    if (f_func != 0) delete f_func;
    if (MRA != 0) delete MRA;
    TelePrompter::printFooter(0, timer, 2);
}

void testTreeCleaner() {
    Timer timer;
    timer.restart();
    println(0, "\n\n======== Testing TreeCleaner =======\n");

    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>();
    GaussFunc<3> *f_func = initializeGauss<3>();

    double prec = Input.get<double>("rel_prec");
    MWProjector<3> Q(*MRA);
    GridCleaner<3> C(*MRA, prec);
    GridGenerator<3> G(*MRA);

    FunctionTree<3> *f_tree = G();

    int n_nodes = 1;
    while (n_nodes > 0) {
        Q(*f_tree, *f_func);
        n_nodes = C(*f_tree);
    }
    Q(*f_tree, *f_func);

    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();
    println(0, " Integral                    " << setw(30) << integral);
    println(0, " Square norm                 " << setw(30) << sq_norm);

    delete f_tree;
    delete f_func;
    delete MRA;
    TelePrompter::printFooter(0, timer, 2);
}

