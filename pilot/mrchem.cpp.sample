/** \mainpage The MRCPP program
 *
 * \author Stig Rune Jensen
 *
 * \version 1.0
 *
 * \par Copyright:
 * GPLv4
 *
 */

#include <Eigen/Core>

#include "parallel.h"
#include "constants.h"
#include "MREnv.h"
#include "TelePrompter.h"
#include "MathUtils.h"

#include "BoundingBox.h"
#include "NodeIndex.h"
#include "MultiResolutionAnalysis.h"
#include "InterpolatingBasis.h"
#include "FunctionTree.h"
#include "PoissonOperator.h"
#include "HelmholtzOperator.h"
#include "MWProjector.h"
#include "MWAdder.h"
#include "MWMultiplier.h"
#include "GridGenerator.h"
#include "GridCleaner.h"
#include "CopyAdaptor.h"
#include "WaveletAdaptor.h"

#include "GaussFunc.h"
#include "HydrogenicFunction.h"
#include "NuclearFunction.h"


using namespace std;
using namespace Eigen;

void testZeroTree();
void testProjection();
void testAddition();
void testMultiplication();
void testGridGenerator();
void testTreeCleaner();
void testPoisson();
void testSCF();

template<int D> MultiResolutionAnalysis<D>* initializeMRA(int order);
template<int D> GaussFunc<D>* initializeGauss(const double *pos = 0);

int main(int argc, char **argv) {
    mpi::environment env(argc, argv);

    Timer rolex;
    rolex.restart();

    int printlevel = 0;
    int printprec = 15;
    bool teletype = false;
    MREnv::initializeMRCPP(printlevel, printprec, teletype);

//    testZeroTree();
//    testProjection();
//    testGridGenerator();
//    testTreeCleaner();
//    testAddition();
//    testMultiplication();
//    testPoisson();
    testSCF();

    MREnv::finalizeMRCPP(rolex);

    return 0;
}

template<int D>
MultiResolutionAnalysis<D>* initializeMRA(int order) {
    // Constructing world box
    int n = -4;
    int l[3] = {-1,-1,-1};
    int nb[3] = {2,2,2};
    NodeIndex<D> idx(n, l);
    BoundingBox<D> world(idx, nb);

    // Constructing scaling basis
    InterpolatingBasis basis(order);

    // Initializing MRA
    return new MultiResolutionAnalysis<D>(world, basis);
}

template<int D>
GaussFunc<D>* initializeGauss(const double *pos) {
    // Constructing analytic function
    double beta = 20.0;
    double alpha = pow(beta/pi, D/2.0);
    int pow[3] = {0, 0, 0};
    if (pos != 0) {
        return new GaussFunc<D>(beta, alpha, pos, pow);
    } else {
        double o[3] = {0.0, 0.0, 0.0};
        return new GaussFunc<D>(beta, alpha, o, pow);
    }
}

void testZeroTree() {
    println(0, "\n\n========= Testing default ==========\n");
    println(0, "\n1D\n");
    {
        MultiResolutionAnalysis<1> *MRA = initializeMRA<1>(2);
        GridGenerator<1> G(*MRA);
        FunctionTree<1> *tree = G();
        tree->setZero();

        double integral = tree->integrate();
        double sq_norm = tree->getSquareNorm();
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);

        delete tree;
        delete MRA;
    }
    println(0, "\n2D\n");
    {
        MultiResolutionAnalysis<2> *MRA = initializeMRA<2>(3);
        GridGenerator<2> G(*MRA);
        FunctionTree<2> *tree = G();
        tree->setZero();

        double integral = tree->integrate();
        double sq_norm = tree->getSquareNorm();
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);

        delete tree;
        delete MRA;
    }
    println(0, "\n3D\n");
    {
        MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(4);
        GridGenerator<3> G(*MRA);
        FunctionTree<3> *tree = G();
        tree->setZero();

        double integral = tree->integrate();
        double sq_norm = tree->getSquareNorm();
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);

        delete tree;
        delete MRA;
    }
    println(0, "\n\n====================================\n\n");
}

void testProjection() {
    println(0, "\n\n======== Testing MWProjector =======\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);
    GaussFunc<3> *f_func = initializeGauss<3>();

    // Setting up adaptor and projector
    double prec = 1.0e-3;
    MWProjector<3> Q(*MRA, prec);

    println(0, "\n\nProjecting function adaptively\n");
    FunctionTree<3> *f_tree = Q(*f_func);

    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    delete f_tree;
    delete f_func;
    delete MRA;
    println(0, "\n\n====================================\n\n");
}

void testGridGenerator() {
    println(0, "\n\n======= Testing GridGenerator ======\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);
    GaussFunc<3> *f_func = initializeGauss<3>();

    double prec = 1.0e-3;
    GridGenerator<3> G(*MRA);
    MWProjector<3> Q(*MRA);
    MWProjector<3> Q_adap(*MRA, prec);

    FunctionTree<3> *f_tree = 0;
    FunctionTree<3> *g_tree = 0;
    FunctionTree<3> *h_tree = 0;

    {
        println(0, "\n\nAdapting analytic function\n");
        f_tree = G(*f_func);
        println(0, "\n\nSetting function to zero");
        f_tree->setZero();

        double integral = f_tree->integrate();
        double sq_norm = f_tree->getSquareNorm();
        println(0, endl);
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);
    }
    println(0, "\n\n------------------------------------");
    {
        println(0, "\n\nAdapting grid\n");
        g_tree = G(*f_tree);
        println(0, "\n\nProjecting function\n");
        Q(*g_tree, *f_func);

        double integral = g_tree->integrate();
        double sq_norm = g_tree->getSquareNorm();
        println(0, endl);
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);
    }
    println(0, "\n\n------------------------------------");
    {
        println(0, "\n\nCopying grid\n");
        h_tree = G();
        G(*h_tree, *g_tree);
        println(0, "\n\nProjecting function adaptively\n");
        Q_adap(*h_tree, *f_func);

        double integral = h_tree->integrate();
        double sq_norm = h_tree->getSquareNorm();
        println(0, endl);
        println(0, "Integral     " << integral);
        println(0, "Square norm  " << sq_norm);
    }

    if (h_tree != 0) delete h_tree;
    if (g_tree != 0) delete g_tree;
    if (f_tree != 0) delete f_tree;
    if (f_func != 0) delete f_func;
    if (MRA != 0) delete MRA;
    println(0, "\n\n====================================\n\n");
}

void testTreeCleaner() {
    println(0, "\n\n======== Testing TreeCleaner =======\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);
    GaussFunc<3> *f_func = initializeGauss<3>();

    double prec = 1.0e-3;
    MWProjector<3> Q(*MRA);
    GridCleaner<3> C(*MRA, prec);
    GridGenerator<3> G(*MRA);

    FunctionTree<3> *f_tree = G();

    int n_nodes = 1;
    while (n_nodes > 0) {
        Q(*f_tree, *f_func);
        n_nodes = C(*f_tree);
    }
    Q(*f_tree, *f_func);

    double integral = f_tree->integrate();
    double sq_norm = f_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    delete f_tree;
    delete f_func;
    delete MRA;
    println(0, "\n\n====================================\n\n");
}

void testAddition() {
    println(0, "\n\nTesting MWAdder\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);

    double prec = 1.0e-3;
    MWProjector<3> Q(*MRA, prec);
    MWAdder<3> add(*MRA);

    double pos_1[3] = {0.0, 0.0, 1.0};
    double pos_2[3] = {0.0, 0.0, -1.0};
    GaussFunc<3> *f_func = initializeGauss<3>(pos_1);
    GaussFunc<3> *g_func = initializeGauss<3>(pos_2);

    FunctionTree<3> *f_tree = Q(*f_func);
    FunctionTree<3> *g_tree = Q(*g_func);

    FunctionTreeVector<3> sum_vec;
    sum_vec.push_back( 1.0, *f_tree);
    sum_vec.push_back(-2.0, *g_tree);
    FunctionTree<3> *h_tree = add(sum_vec);

    println(0, *f_tree);
    println(0, *g_tree);
    println(0, *h_tree);

    double integral = h_tree->integrate();
    double sq_norm = h_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    delete f_tree;
    delete g_tree;
    delete h_tree;
    delete f_func;
    delete g_func;
    delete MRA;
}

void testMultiplication() {
    println(0, "\n\nTesting MWMultiplier\n");
    MultiResolutionAnalysis<3> *MRA = initializeMRA<3>(5);

    double prec = 1.0e-5;
    MWProjector<3> Q(*MRA, prec);
    MWMultiplier<3> mult(*MRA, prec);

    GaussFunc<3> *f_func = initializeGauss<3>();
    GaussFunc<3> *g_func = initializeGauss<3>();

    FunctionTree<3> *f_tree = Q(*f_func);
    FunctionTree<3> *g_tree = Q(*g_func);

    FunctionTreeVector<3> prod_vec;
    prod_vec.push_back(*f_tree);
    prod_vec.push_back(*g_tree);
    FunctionTree<3> *h_tree = mult(prod_vec);
    prod_vec.clear();

    double integral = h_tree->integrate();
    double sq_norm = h_tree->getSquareNorm();
    println(0, endl);
    println(0, "Integral     " << integral);
    println(0, "Square norm  " << sq_norm);

    delete f_tree;
    delete g_tree;
    delete h_tree;
    delete f_func;
    delete g_func;
    delete MRA;
}

void testPoisson() {
    Timer analy_t, proj_t, build_t, apply_t;
    println(0, "\n\nTesting Poisson operator\n");

    // Computational domain [0,32]
    int n = -6;
    NodeIndex<3> idx(n);
    BoundingBox<3> world(idx);

    // Constructing scaling basis
    int k = 7;
    InterpolatingBasis basis(k);

    // Initializing MRA
    MultiResolutionAnalysis<3> MRA(world, basis);

    double proj_prec = 1.0e-4;
    double apply_prec = 1.0e-4;
    double build_prec = 1.0e-4;

    GridGenerator<3> G(MRA);
    MWProjector<3> Q(MRA, proj_prec);

    double alpha = 100.0;
    double coef = pow(alpha/pi, 3.0/2.0);
    double pos[3] = {pi,pi,pi};
    int pow[3] = {0,0,0};
    GaussFunc<3> f_func(alpha, coef, pos, pow);

    printout(0, endl);
    println(0, "================= Computing analytic energy ================");
    printout(0, endl);
    analy_t.restart();
    double analyticEnergy = f_func.calcCoulombEnergy(f_func);
    analy_t.stop();
    println(0, "Time analytic:      " << analy_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "=================== Projecting function ====================");
    printout(0, endl);
    proj_t.restart();
    FunctionTree<3> *f_tree = Q(f_func);
    proj_t.stop();
    println(0, "Time projection:    " << proj_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "================== Constructing operator ===================");
    printout(0, endl);
    build_t.restart();
    PoissonOperator P(MRA, apply_prec, build_prec);
    build_t.stop();
    println(0, "Time construction:  " << build_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "==================== Applying operator =====================");
    printout(0, endl);
    apply_t.restart();
    FunctionTree<3> *g_tree = G();
    P(*g_tree, *f_tree);
    apply_t.stop();
    println(0, "Time application:   " << apply_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    println(0, *f_tree);
    println(0, *g_tree);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    double fInt = f_tree->integrate();
    double fNorm = sqrt(f_tree->getSquareNorm());
    double gInt = g_tree->integrate();
    double gNorm = sqrt(g_tree->getSquareNorm());
    double numericalEnergy = g_tree->dot(*f_tree);
    double error = (numericalEnergy-analyticEnergy)/numericalEnergy;

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    println(0, "f_func integral:              " << setw(30) << fInt);
    println(0, "f_func norm:                  " << setw(30) << fNorm << endl);
    println(0, "g_func integral:              " << setw(30) << gInt);
    println(0, "g_func norm:                  " << setw(30) << gNorm << endl);
    println(0, "Analytic energy:              " << setw(30) << analyticEnergy);
    println(0, "Numerical energy:             " << setw(30) << numericalEnergy);
    println(0, "Relative error:               " << setw(30) << error);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    println(0, "Time analytic:      " << analy_t);
    println(0, "Time projection:    " << proj_t);
    println(0, "Time construction:  " << build_t);
    println(0, "Time application:   " << apply_t);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    delete f_tree;
    delete g_tree;
}

void testSCF() {
    Timer analy_t, nuc_t, init_t;
    int order = 5;
    double rel_prec = 1.0e-3;

    double proj_prec = rel_prec;
    double apply_prec = rel_prec;
    double build_prec = rel_prec/10.0;
    double scf_prec = rel_prec*10.0;

    // Computational domain [-32.0, 32.0]
    int scale = -5;
    int corner[3] = {-1, -1, -1};
    int nbox[3] = {2, 2, 2};
    NodeIndex<3> idx(scale, corner);
    BoundingBox<3> box(idx, nbox);

    InterpolatingBasis basis(order);
    MultiResolutionAnalysis<3> MRA(box, basis);

    FunctionTreeVector<3> tree_vec;
    MWAdder<3> add(MRA);
    MWMultiplier<3> mult(MRA, proj_prec);
    MWProjector<3> Q(MRA, proj_prec);
    GridGenerator<3> G(MRA);

    // Analytic solution
    int n = 1;                  // Principal quantum number
    int l = 0;                  // Angular quantum number
    int m_l = 0;                // Magnetic quantum number
    double Z = 1.0;             // Nuclear charge
    double E = -Z/(2.0*n*n);    // Total energy
    double pos[3] = {0.0, 0.0, 0.0};

    FunctionTree<3> *Vphi = 0;
    FunctionTree<3> *d_phi_n = 0;
    FunctionTree<3> *phi_np1 = 0;
    FunctionTree<3> *phi_n = 0;

    printout(0, endl);
    println(0, "================ Projecting analytic solution ==============");
    printout(0, endl);
    analy_t.restart();
    HydrogenicFunction hFunc(n, l, m_l, Z, pos);
    FunctionTree<3> *psi = Q(hFunc);
    analy_t.stop();
    println(0, "Time analytic:      " << analy_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "================ Projecting nuclear potential ==============");
    printout(0, endl);
    nuc_t.restart();
    NuclearFunction nucFunc;
    nucFunc.addNucleus(pos, Z, 1.0e-6);
    FunctionTree<3> *V = Q(nucFunc);
    nuc_t.stop();
    println(0, "Time nuc pot:       " << nuc_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "================== Projecting initial guess ================");
    printout(0, endl);
    init_t.restart();
    GaussFunc<3> g_func(10.0, 1.0, pos);
    phi_n = Q(g_func);
    phi_n->normalize();
    init_t.stop();
    println(0, "Time initial guess: " << init_t << endl);
    println(0, "============================================================");
    printout(0, endl);

    double eps_n = -0.5;
    double eps_np1 = 0.0;
    double d_eps_n = 0.0;

    TelePrompter::setPrecision(5);

    printout(0, endl);
    println(0, "======================== Running SCF =======================");
    printout(0, endl);

    printout(0, endl);
    printout(0, "Iter");
    printout(0, "      E_np1          dE_n   ");
    printout(0, "   ||phi_np1||    ||dPhi_n||");
    printout(0, endl << endl);

    int iter = 1;
    double residual = 1.0;
    vector<Timer> scf_t;
    while (residual > scf_prec) {
        Timer cycle_t;
        cycle_t.restart();
        if (eps_n > 0.0) eps_n *= -1.0;
        double mu_n = sqrt(-2*eps_n);
        HelmholtzOperator H(MRA, mu_n, apply_prec, build_prec);

        tree_vec.push_back(*V);
        tree_vec.push_back(*phi_n);
        Vphi = G(tree_vec);
        mult(*Vphi, tree_vec, 1);
        tree_vec.clear();

        phi_np1 = G(*phi_n);
        H(*phi_np1, *Vphi);
        *phi_np1 *= -1.0/(2.0*pi);
        delete Vphi;

        tree_vec.push_back(1.0, *phi_np1);
        tree_vec.push_back(-1.0, *phi_n);
        d_phi_n = add(tree_vec);
        tree_vec.clear();

        tree_vec.push_back(*V);
        tree_vec.push_back(*phi_np1);
        Vphi = G(tree_vec);
        mult(*Vphi, tree_vec, 1);
        tree_vec.clear();

        double norm = sqrt(phi_np1->getSquareNorm());
        residual = sqrt(d_phi_n->getSquareNorm());
        d_eps_n = d_phi_n->dot(*Vphi)/(norm*norm);
        eps_np1 = eps_n + d_eps_n;
        delete Vphi;

        printout(0, setw(4) << iter);
        printout(0, setw(14) << eps_np1);
        printout(0, setw(14) << d_eps_n);
        printout(0, setw(14) << norm);
        printout(0, setw(14) << residual);
        printout(0, endl);

        delete d_phi_n;
        delete phi_n;

        eps_n = eps_np1;
        phi_n = phi_np1;
        phi_n->normalize();

        cycle_t.stop();
        scf_t.push_back(cycle_t);
        iter++;
    }
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    printout(0, endl);
    println(0, "======================== SCF timings =======================");
    printout(0, endl);
    for (int i = 0; i < scf_t.size(); i++) {
        println(0, "Time SCF cycle:     " << scf_t[i]);
    }
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    tree_vec.push_back(1.0, *phi_n);
    tree_vec.push_back(-1.0, *psi);
    d_phi_n = add(tree_vec);
    tree_vec.clear();

    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);
    double error = sqrt(d_phi_n->getSquareNorm());
    println(0, "Final energy   " << setw(20) << eps_n    << setw(20) << (E - eps_n));
    println(0, "Final residual " << setw(20) << residual << setw(20) << error);
    printout(0, endl);
    println(0, "============================================================");
    printout(0, endl);

    delete d_phi_n;
    delete phi_n;
    delete psi;
    delete V;
}
