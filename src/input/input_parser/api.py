# -*- coding: utf-8 -*-

# This file was automatically generated by parselglossy on 2020-08-25
# Editing is *STRONGLY DISCOURAGED*

import json
from pathlib import Path
from typing import Optional, Union

from .plumbing import lexer
from .plumbing.utils import JSONDict, as_complex, path_resolver, copier
from .plumbing.validation import validate_from_dicts


def lex(
    infile: Union[str, Path],
    ir_file: Optional[Union[str, Path]] = None,
) -> JSONDict:
    """Run grammar of choice on input string.

    Parameters
    ----------
    infile : Union[str, Path]
        The string to be parsed.
    ir_file : Optional[Union[str, Path]]
        File to write intermediate representation to (JSON format).
        None by default, which means file is not written out.

    Returns
    -------
    The contents of the input string as a dictionary.
    """

    infile = path_resolver(infile)
    if ir_file is not None:
        ir_file = path_resolver(ir_file)

    with infile.open("r") as f:
        ir = lexer.lex_from_str(in_str=f.read(), ir_file=ir_file)

    return ir


def validate(
    infile: Union[str, Path],
    fr_file: Optional[Union[str, Path]] = None,
) -> JSONDict:
    """Validate intermediate representation into final representation.

    Parameters
    ----------
    infile : Union[str, Path]
        The file with the intermediate representation (JSON format).
    fr_file : Optional[Union[str, Path]]
        File to write final representation to (JSON format).
        None by default, which means file is not written out.

    Returns
    -------
    The validated input as a dictionary.
    """

    infile = path_resolver(infile)
    with infile.open("r") as f:
        ir = json.load(f, object_hook=as_complex)

    stencil = {'keywords': [{'name': 'world_prec', 'type': 'float', 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Overall relative precision in the calculation.\n'}, {'name': 'world_size', 'type': 'int', 'default': -1, 'predicates': ['value <= 10'], 'docstring': 'Total size of computational domain given as 2**(``world_size``). Always cubic\nand symmetric around the origin. Negative value means it will be computed\nfrom the molecular geometry.\n'}, {'name': 'world_unit', 'type': 'str', 'default': 'bohr', 'predicates': ['value.lower() in ["bohr", "angstrom"]'], 'docstring': 'Length unit for *all* coordinates given in user input. Everything will be\nconverted to atomic units (bohr) before the main executable is launched,\nso the JSON input is *always* given in bohrs.\n'}, {'name': 'world_origin', 'type': 'List[float]', 'default': [0.0, 0.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'Global gauge origin of the calculation.\n'}], 'sections': [{'name': 'Precisions', 'docstring': 'Define specific precision parameters.\n', 'keywords': [{'name': 'helmholtz_prec', 'type': 'float', 'default': "user['world_prec']", 'docstring': 'Precision parameter used in construction of Helmholtz operators.\nNegative value means it will follow the dynamic precision in SCF.\n'}, {'name': 'poisson_prec', 'type': 'float', 'default': "user['world_prec']", 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in construction of Poisson operators.\n'}, {'name': 'nuclear_prec', 'type': 'float', 'default': "user['world_prec']", 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in smoothing and projection of nuclear potential.\n'}]}, {'name': 'Printer', 'docstring': 'Define variables for printed output.\n', 'keywords': [{'name': 'print_level', 'type': 'int', 'default': 0, 'docstring': 'Level of detail in the written output. Level 0 for production\ncalculations, negative level for complete silence.\n'}, {'name': 'print_mpi', 'type': 'bool', 'default': False, 'docstring': 'Write separate output from each MPI to file called ``<file_name>-<mpi-rank>.out``.\n'}, {'name': 'print_prec', 'type': 'int', 'default': 6, 'predicates': ['0 < value < 10'], 'docstring': 'Number of digits in property output (energies will get twice this\nnumber of digits).\n'}, {'name': 'print_width', 'type': 'int', 'default': 75, 'predicates': ['50 < value < 100'], 'docstring': 'Line width of printed output (in number of characters).\n'}]}, {'name': 'Plotter', 'docstring': 'Give details regarding the density and orbital plots. Three types of\nplots are available, line, surface and cube, and the plotting ranges\nare defined by three vectors (A, B and C) and an origin (O):\n``line``: plots on line spanned by A, starting from O.\n``surf``: plots on surface spanned by A and B, starting from O.\n``cube``: plots on volume spanned by A, B and C, starting from O.\n', 'keywords': [{'name': 'path', 'type': 'str', 'default': 'plots', 'predicates': ["value[-1] != '/'"], 'docstring': 'File path to plot directory.\n'}, {'name': 'type', 'type': 'str', 'default': 'cube', 'predicates': ["value.lower() in ['line', 'surf', 'cube']"], 'docstring': 'Type of plot: line (1D), surface (2D) or cube (3D).\n'}, {'name': 'points', 'type': 'List[int]', 'default': [20, 20, 20], 'predicates': ['all(p > 0 for p in value)', "not (user['Plotter']['type'] == 'line' and len(value) < 1)", "not (user['Plotter']['type'] == 'surf' and len(value) < 2)", "not (user['Plotter']['type'] == 'cube' and len(value) < 3)"], 'docstring': 'Number of points in each direction on the cube grid.\n'}, {'name': 'O', 'type': 'List[float]', 'default': [0.0, 0.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'Origin of plotting ranges.\n'}, {'name': 'A', 'type': 'List[float]', 'default': [1.0, 0.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'First boundary vector for plot.\n'}, {'name': 'B', 'type': 'List[float]', 'default': [0.0, 1.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'Second boundary vector for plot.\n'}, {'name': 'C', 'type': 'List[float]', 'default': [0.0, 0.0, 1.0], 'predicates': ['len(value) == 3'], 'docstring': 'Third boundary vector for plot.\n'}]}, {'name': 'MPI', 'docstring': 'Define MPI related parameters.\n', 'keywords': [{'name': 'numerically_exact', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI algorithms that guarantees that the output is\ninvariant wrt the number of MPI processes.\n'}, {'name': 'shared_memory_size', 'type': 'int', 'default': 10000, 'docstring': 'Size (MB) of the MPI shared memory blocks of each shared function.\n'}, {'name': 'share_nuclear_potential', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI shared memory for the nuclear potential.\n'}, {'name': 'share_coulomb_potential', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI shared memory for the Coulomb potential.\n'}, {'name': 'share_xc_potential', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI shared memory for the exchange-correlation potential.\n'}, {'name': 'bank_size', 'type': 'int', 'default': -1, 'docstring': 'Number of MPI processes exclusively dedicated to manage orbital bank.\n'}]}, {'name': 'Basis', 'docstring': 'Define polynomial basis.\n', 'keywords': [{'name': 'order', 'type': 'int', 'default': -1, 'docstring': 'Polynomial order of multiwavelet basis. Negative value means it will\nbe set automatically based on the world precision.\n'}, {'name': 'type', 'type': 'str', 'default': 'interpolating', 'predicates': ["value.lower() in ['interpolating', 'legendre']"], 'docstring': 'Polynomial type of multiwavelet basis.\n'}]}, {'name': 'Derivatives', 'docstring': 'Define various derivative operators used in the code.\n', 'keywords': [{'name': 'kinetic', 'type': 'str', 'default': 'abgv_55', 'docstring': 'Derivative used in kinetic operator.\n'}, {'name': 'h_b_dip', 'type': 'str', 'default': 'abgv_00', 'docstring': 'Derivative used in magnetic dipole operator.\n'}, {'name': 'h_m_pso', 'type': 'str', 'default': 'abgv_00', 'docstring': 'Derivative used in paramagnetic spin-orbit operator.\n'}]}, {'name': 'Molecule', 'docstring': 'Define molecule.\n', 'keywords': [{'name': 'charge', 'type': 'int', 'default': 0, 'docstring': 'Total charge of molecule.\n'}, {'name': 'multiplicity', 'type': 'int', 'default': 1, 'docstring': 'Spin multiplicity of molecule.\n'}, {'name': 'translate', 'type': 'bool', 'default': False, 'docstring': 'Translate coordinates such that center of mass coincides with\nthe global gauge origin.\n'}, {'name': 'coords', 'type': 'str', 'docstring': 'Coordinates in xyz format.\n'}]}, {'name': 'WaveFunction', 'docstring': 'Define the wavefunction method.\n', 'keywords': [{'name': 'method', 'type': 'str', 'predicates': ["value.lower() in ['core', 'hartree', 'hf', 'hartreefock', 'hartree-fock', 'dft', 'lda', 'svwn3', 'svwn5', 'pbe', 'pbe0', 'bpw91', 'bp86', 'b3p86', 'b3p86-g', 'blyp', 'b3lyp', 'b3lyp-g', 'olyp', 'kt1', 'kt2', 'kt3']"], 'docstring': 'Wavefunction method. See predicates for valid methods. ``hf``,\n``hartreefock`` and ``hartree-fock`` all mean the same thing, while ``lda``\nis an alias for ``svwn5``. You can set a non-standard DFT functional\n(e.g. varying the amount of exact exchange) by choosing ``dft`` and\nspecifing the functional(s) in the ``DFT`` section below.\n'}, {'name': 'restricted', 'type': 'bool', 'default': True, 'docstring': 'Use spin restricted wavefunction.\n'}]}, {'name': 'DFT', 'docstring': 'Define the exchange-correlation functional in case of DFT.\n', 'keywords': [{'name': 'density_cutoff', 'type': 'float', 'default': 0.0, 'docstring': 'Hard cutoff for passing density values to XCFun.\n'}, {'name': 'functionals', 'type': 'str', 'default': ' ', 'docstring': 'List of density functionals with numerical coefficient. E.g. for PBE0\n``EXX 0.25``, ``PBEX 0.75``, ``PBEC 1.0``, see XCFun\ndocumentation <https://xcfun.readthedocs.io/>_.\n'}, {'name': 'spin', 'type': 'bool', 'default': "not(user['WaveFunction']['restricted'])", 'docstring': 'Use spin separated density functionals.\n'}]}, {'name': 'Properties', 'docstring': 'Provide a list of properties to compute (total SCF energy and orbital\nenergies are always computed).\n', 'keywords': [{'name': 'dipole_moment', 'type': 'bool', 'default': False, 'docstring': 'Compute dipole moment.\n'}, {'name': 'quadrupole_moment', 'type': 'bool', 'default': False, 'docstring': 'Compute quadrupole moment. Note: Gauge origin dependent, should be\nused with ``translate = true`` in Molecule.\n'}, {'name': 'polarizability', 'type': 'bool', 'default': False, 'docstring': 'Compute polarizability tensor.\n'}, {'name': 'magnetizability', 'type': 'bool', 'default': False, 'docstring': 'Compute magnetizability tensor.\n'}, {'name': 'nmr_shielding', 'type': 'bool', 'default': False, 'docstring': 'Compute NMR shielding tensor.\n'}, {'name': 'plot_density', 'type': 'bool', 'default': False, 'docstring': 'Plot converged electron density.\n'}, {'name': 'plot_orbitals', 'type': 'List[int]', 'default': [], 'docstring': 'Plot converged molecular orbitals from list of indices, negative index\nplots all orbitals.\n'}]}, {'name': 'ExternalFields', 'docstring': 'Define external electromagnetic fields.\n', 'keywords': [{'name': 'electric_field', 'type': 'List[float]', 'default': [], 'predicates': ['len(value) == 0 or len(value) == 3'], 'docstring': 'Strength of external electric field.\n'}]}, {'name': 'Polarizability', 'docstring': 'Give details regarding the polarizability calculation.\n', 'keywords': [{'name': 'frequency', 'type': 'List[float]', 'default': [0.0], 'docstring': 'List of external field frequencies.\n'}]}, {'name': 'NMRShielding', 'docstring': 'Give details regarding the NMR shileding calculation.\n', 'keywords': [{'name': 'nuclear_specific', 'type': 'bool', 'default': False, 'docstring': 'Use nuclear specific perturbation operator (h_m_pso).\n'}, {'name': 'nucleus_k', 'type': 'List[int]', 'default': [-1], 'docstring': 'List of nuclei to compute. Negative value computes all nuclei.\n'}]}, {'name': 'Files', 'docstring': 'Defines file paths used for program input/output.\nNote: all paths must be given in quotes if they contain slashes\n"path/to/file".\n', 'keywords': [{'name': 'guess_basis', 'type': 'str', 'default': 'initial_guess/mrchem.bas', 'docstring': 'File name for GTO basis set, used with ``gto`` guess.\n'}, {'name': 'guess_gto_p', 'type': 'str', 'default': 'initial_guess/mrchem.mop', 'docstring': 'File name for paired orbitals, used with ``gto`` guess.\n'}, {'name': 'guess_gto_a', 'type': 'str', 'default': 'initial_guess/mrchem.moa', 'docstring': 'File name for alpha orbitals, used with ``gto`` guess.\n'}, {'name': 'guess_gto_b', 'type': 'str', 'default': 'initial_guess/mrchem.mob', 'docstring': 'File name for beta orbitals, used with ``gto`` guess.\n'}, {'name': 'guess_phi_p', 'type': 'str', 'default': 'initial_guess/phi_p', 'docstring': 'File name for paired orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_phi_a', 'type': 'str', 'default': 'initial_guess/phi_a', 'docstring': 'File name for alpha orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_phi_b', 'type': 'str', 'default': 'initial_guess/phi_b', 'docstring': 'File name for beta orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_x_p', 'type': 'str', 'default': 'initial_guess/X_p', 'docstring': 'File name for paired response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_x_a', 'type': 'str', 'default': 'initial_guess/X_a', 'docstring': 'File name for alpha response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_x_b', 'type': 'str', 'default': 'initial_guess/X_b', 'docstring': 'File name for beta response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_y_p', 'type': 'str', 'default': 'initial_guess/Y_p', 'docstring': 'File name for paired response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_y_a', 'type': 'str', 'default': 'initial_guess/Y_a', 'docstring': 'File name for alpha response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_y_b', 'type': 'str', 'default': 'initial_guess/Y_b', 'docstring': 'File name for beta response orbitals, used with ``mw`` guess.\n'}]}, {'name': 'SCF', 'docstring': 'Includes parameters related to the ground state SCF orbital optimization.\n', 'keywords': [{'name': 'run', 'type': 'bool', 'default': True, 'docstring': 'Run SCF solver. Otherwise properties are computed on the initial orbitals.\n'}, {'name': 'max_iter', 'type': 'int', 'default': 100, 'docstring': 'Maximum number of SCF iterations.\n'}, {'name': 'kain', 'type': 'int', 'default': 5, 'docstring': 'Length of KAIN iterative history.\n'}, {'name': 'rotation', 'type': 'int', 'default': 0, 'docstring': 'Number of iterations between each diagonalization/localization.\n'}, {'name': 'localize', 'type': 'bool', 'default': False, 'docstring': 'Use canonical or localized orbitals.\n'}, {'name': 'energy_thrs', 'type': 'float', 'default': -1.0, 'docstring': 'Convergence threshold for SCF energy.\n'}, {'name': 'guess_prec', 'type': 'float', 'default': 0.001, 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in construction of initial guess.\n'}, {'name': 'start_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, initial value.\n'}, {'name': 'final_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, final value.\n'}, {'name': 'guess_type', 'type': 'str', 'default': 'sad_dz', 'predicates': ["value.lower() in ['mw', 'chk', 'gto', 'core_sz', 'core_dz', 'core_tz', 'core_qz', 'sad_sz', 'sad_dz', 'sad_tz', 'sad_qz']"], 'docstring': 'Type of initial guess for ground state orbitals.\n``chk`` restarts a previous calculation which was dumped using the\n``write_checkpoint`` keyword. This will load MRA and electron spin\nconfiguration directly from the checkpoint files, which are thus\nrequired to be identical in the two calculations.\n``mw`` will start from final orbitals in a previous calculation written\nusing the ``write_orbitals`` keyword. The orbitals will be re-projected\ninto the new computational setup, which means that the electron spin\nconfiguration and MRA can be different in the two calculations.\n``gto`` reads precomputed GTO orbitals (requires extra non-standard\ninput files for basis set and MO coefficients).\n``core`` and ``sad`` will diagonalize the Fock matrix in the given AO\nbasis (SZ, DZ, TZ or QZ) using a Core or Superposition of Atomic\nDensities Hamiltonian, respectively.\n'}, {'name': 'write_checkpoint', 'type': 'bool', 'default': False, 'docstring': 'Write orbitals to disk in each iteration, file name\n``<path_checkpoint>/phi_scf_idx_<0..N>``. Can be used as ``chk`` initial\nguess in subsequent calculations. Note: must be given in quotes if\nthere are slashes in the path "path/to/checkpoint".\n'}, {'name': 'path_checkpoint', 'type': 'str', 'default': 'checkpoint', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to checkpoint files during SCF, used with ``write_checkpoint``\nand ``chk`` guess.\n'}, {'name': 'write_orbitals', 'type': 'bool', 'default': False, 'docstring': 'Write final orbitals to disk, file name\n``<path_orbitals>/phi_<p/a/b>_scf_idx_<0..Np/Na/Nb>``.\nCan be used as ``mw`` initial guess in subsequent calculations.\n'}, {'name': 'path_orbitals', 'type': 'str', 'default': 'orbitals', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to where converged orbitals will be written in connection with\nthe ``write_orbitals`` keyword. Note: must be given in quotes if\nthere are slashes in the path "path/to/orbitals".\n'}, {'name': 'orbital_thrs', 'type': 'float', 'default': "10 * user['world_prec']", 'docstring': 'Convergence threshold for orbital residuals.\n'}]}, {'name': 'Response', 'docstring': 'Includes parameters related to the response SCF optimization.\n', 'keywords': [{'name': 'run', 'type': 'List[bool]', 'default': [True, True, True], 'docstring': 'In which Cartesian directions to run response solver.\n'}, {'name': 'max_iter', 'type': 'int', 'default': 100, 'docstring': 'Maximum number of response iterations.\n'}, {'name': 'kain', 'type': 'int', 'default': 5, 'docstring': 'Length of KAIN iterative history.\n'}, {'name': 'property_thrs', 'type': 'float', 'default': -1.0, 'docstring': 'Convergence threshold for symmetric property. Symmetric meaning the\nproperty computed from the same operator as the response purturbation,\ne.g. for external magnetic field the symmetric property corresponds to\nthe magnetizability (NMR shielding in non-symmetric, since one of the\noperators is external magnetic field, while the other is nuclear\nmagnetic moment).\n'}, {'name': 'start_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, initial value.\n'}, {'name': 'final_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, final value.\n'}, {'name': 'guess_prec', 'type': 'float', 'default': 0.001, 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in construction of initial guess.\n'}, {'name': 'guess_type', 'type': 'str', 'default': 'none', 'predicates': ["value.lower() in ['none', 'chk', 'mw']"], 'docstring': 'Type of initial guess for response.\n``none`` will start from a zero guess for the response functions.\n``chk`` restarts a previous calculation which was dumped using the\n``write_checkpoint`` keyword.\n``mw`` will start from final orbitals in a previous calculation written\nusing the ``write_orbitals`` keyword. The orbitals will be re-projected\ninto the new computational setup.\n'}, {'name': 'write_checkpoint', 'type': 'bool', 'default': False, 'docstring': 'Write perturbed orbitals to disk in each iteration, file name\n``<path_checkpoint>/<X/Y>_rsp_<direction>_idx_<0..N>``. Can be used as ``chk``\ninitial guess in subsequent calculations.\n'}, {'name': 'path_checkpoint', 'type': 'str', 'default': 'checkpoint', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to checkpoint files during SCF, used with ``write_checkpoint``\nand ``chk`` guess.\n'}, {'name': 'write_orbitals', 'type': 'bool', 'default': False, 'docstring': 'Write final perturbed orbitals to disk, file name\n``<path_orbitals>/<X/Y>_<p/a/b>_rsp_<direction>_idx_<0..Np/Na/Nb>``.\nCan be used as ``mw`` initial guess in subsequent calculations.\n'}, {'name': 'path_orbitals', 'type': 'str', 'default': 'orbitals', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to where converged orbitals will be written in connection with\nthe ``write_orbitals`` keyword.\n'}, {'name': 'orbital_thrs', 'type': 'float', 'default': "10 * user['world_prec']", 'docstring': 'Convergence threshold for orbital residuals.\n'}, {'name': 'localize', 'type': 'bool', 'default': "user['SCF']['localize']", 'docstring': 'Use canonical or localized unperturbed orbitals.\n'}]}]}

    if fr_file is not None:
        fr_file = path_resolver(fr_file)

    return validate_from_dicts(ir=ir, template=stencil, fr_file=fr_file)


def parse(
    infile: Union[str, Path],
    outfile: Optional[Union[str, Path]] = None,
    dump_ir: bool = False,
) -> JSONDict:
    """Parse input file.

    Parameters
    ----------
    infile : Union[str, Path]
        The input file to be parsed.
    outfile : Optional[Union[str, Path]]
        The output file.
        Defaults to ``None``, which means writing to ``<infile>_fr.json``.
    dump_ir : bool
        Whether to write out the intermediate representation to file (JSON format).
        False by default. If true the filename if ``<infile>_ir.json``

    Returns
    -------
    The validated input as a dictionary.
    """

    infile = path_resolver(infile)

    ir_file = None  # type: Optional[Path]
    if dump_ir:
        ir_file = path_resolver(Path(infile).stem + "_ir.json")

    ir = lex(infile=infile, ir_file=ir_file)

    stencil = {'keywords': [{'name': 'world_prec', 'type': 'float', 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Overall relative precision in the calculation.\n'}, {'name': 'world_size', 'type': 'int', 'default': -1, 'predicates': ['value <= 10'], 'docstring': 'Total size of computational domain given as 2**(``world_size``). Always cubic\nand symmetric around the origin. Negative value means it will be computed\nfrom the molecular geometry.\n'}, {'name': 'world_unit', 'type': 'str', 'default': 'bohr', 'predicates': ['value.lower() in ["bohr", "angstrom"]'], 'docstring': 'Length unit for *all* coordinates given in user input. Everything will be\nconverted to atomic units (bohr) before the main executable is launched,\nso the JSON input is *always* given in bohrs.\n'}, {'name': 'world_origin', 'type': 'List[float]', 'default': [0.0, 0.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'Global gauge origin of the calculation.\n'}], 'sections': [{'name': 'Precisions', 'docstring': 'Define specific precision parameters.\n', 'keywords': [{'name': 'helmholtz_prec', 'type': 'float', 'default': "user['world_prec']", 'docstring': 'Precision parameter used in construction of Helmholtz operators.\nNegative value means it will follow the dynamic precision in SCF.\n'}, {'name': 'poisson_prec', 'type': 'float', 'default': "user['world_prec']", 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in construction of Poisson operators.\n'}, {'name': 'nuclear_prec', 'type': 'float', 'default': "user['world_prec']", 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in smoothing and projection of nuclear potential.\n'}]}, {'name': 'Printer', 'docstring': 'Define variables for printed output.\n', 'keywords': [{'name': 'print_level', 'type': 'int', 'default': 0, 'docstring': 'Level of detail in the written output. Level 0 for production\ncalculations, negative level for complete silence.\n'}, {'name': 'print_mpi', 'type': 'bool', 'default': False, 'docstring': 'Write separate output from each MPI to file called ``<file_name>-<mpi-rank>.out``.\n'}, {'name': 'print_prec', 'type': 'int', 'default': 6, 'predicates': ['0 < value < 10'], 'docstring': 'Number of digits in property output (energies will get twice this\nnumber of digits).\n'}, {'name': 'print_width', 'type': 'int', 'default': 75, 'predicates': ['50 < value < 100'], 'docstring': 'Line width of printed output (in number of characters).\n'}]}, {'name': 'Plotter', 'docstring': 'Give details regarding the density and orbital plots. Three types of\nplots are available, line, surface and cube, and the plotting ranges\nare defined by three vectors (A, B and C) and an origin (O):\n``line``: plots on line spanned by A, starting from O.\n``surf``: plots on surface spanned by A and B, starting from O.\n``cube``: plots on volume spanned by A, B and C, starting from O.\n', 'keywords': [{'name': 'path', 'type': 'str', 'default': 'plots', 'predicates': ["value[-1] != '/'"], 'docstring': 'File path to plot directory.\n'}, {'name': 'type', 'type': 'str', 'default': 'cube', 'predicates': ["value.lower() in ['line', 'surf', 'cube']"], 'docstring': 'Type of plot: line (1D), surface (2D) or cube (3D).\n'}, {'name': 'points', 'type': 'List[int]', 'default': [20, 20, 20], 'predicates': ['all(p > 0 for p in value)', "not (user['Plotter']['type'] == 'line' and len(value) < 1)", "not (user['Plotter']['type'] == 'surf' and len(value) < 2)", "not (user['Plotter']['type'] == 'cube' and len(value) < 3)"], 'docstring': 'Number of points in each direction on the cube grid.\n'}, {'name': 'O', 'type': 'List[float]', 'default': [0.0, 0.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'Origin of plotting ranges.\n'}, {'name': 'A', 'type': 'List[float]', 'default': [1.0, 0.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'First boundary vector for plot.\n'}, {'name': 'B', 'type': 'List[float]', 'default': [0.0, 1.0, 0.0], 'predicates': ['len(value) == 3'], 'docstring': 'Second boundary vector for plot.\n'}, {'name': 'C', 'type': 'List[float]', 'default': [0.0, 0.0, 1.0], 'predicates': ['len(value) == 3'], 'docstring': 'Third boundary vector for plot.\n'}]}, {'name': 'MPI', 'docstring': 'Define MPI related parameters.\n', 'keywords': [{'name': 'numerically_exact', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI algorithms that guarantees that the output is\ninvariant wrt the number of MPI processes.\n'}, {'name': 'shared_memory_size', 'type': 'int', 'default': 10000, 'docstring': 'Size (MB) of the MPI shared memory blocks of each shared function.\n'}, {'name': 'share_nuclear_potential', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI shared memory for the nuclear potential.\n'}, {'name': 'share_coulomb_potential', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI shared memory for the Coulomb potential.\n'}, {'name': 'share_xc_potential', 'type': 'bool', 'default': False, 'docstring': 'This will use MPI shared memory for the exchange-correlation potential.\n'}, {'name': 'bank_size', 'type': 'int', 'default': -1, 'docstring': 'Number of MPI processes exclusively dedicated to manage orbital bank.\n'}]}, {'name': 'Basis', 'docstring': 'Define polynomial basis.\n', 'keywords': [{'name': 'order', 'type': 'int', 'default': -1, 'docstring': 'Polynomial order of multiwavelet basis. Negative value means it will\nbe set automatically based on the world precision.\n'}, {'name': 'type', 'type': 'str', 'default': 'interpolating', 'predicates': ["value.lower() in ['interpolating', 'legendre']"], 'docstring': 'Polynomial type of multiwavelet basis.\n'}]}, {'name': 'Derivatives', 'docstring': 'Define various derivative operators used in the code.\n', 'keywords': [{'name': 'kinetic', 'type': 'str', 'default': 'abgv_55', 'docstring': 'Derivative used in kinetic operator.\n'}, {'name': 'h_b_dip', 'type': 'str', 'default': 'abgv_00', 'docstring': 'Derivative used in magnetic dipole operator.\n'}, {'name': 'h_m_pso', 'type': 'str', 'default': 'abgv_00', 'docstring': 'Derivative used in paramagnetic spin-orbit operator.\n'}]}, {'name': 'Molecule', 'docstring': 'Define molecule.\n', 'keywords': [{'name': 'charge', 'type': 'int', 'default': 0, 'docstring': 'Total charge of molecule.\n'}, {'name': 'multiplicity', 'type': 'int', 'default': 1, 'docstring': 'Spin multiplicity of molecule.\n'}, {'name': 'translate', 'type': 'bool', 'default': False, 'docstring': 'Translate coordinates such that center of mass coincides with\nthe global gauge origin.\n'}, {'name': 'coords', 'type': 'str', 'docstring': 'Coordinates in xyz format.\n'}]}, {'name': 'WaveFunction', 'docstring': 'Define the wavefunction method.\n', 'keywords': [{'name': 'method', 'type': 'str', 'predicates': ["value.lower() in ['core', 'hartree', 'hf', 'hartreefock', 'hartree-fock', 'dft', 'lda', 'svwn3', 'svwn5', 'pbe', 'pbe0', 'bpw91', 'bp86', 'b3p86', 'b3p86-g', 'blyp', 'b3lyp', 'b3lyp-g', 'olyp', 'kt1', 'kt2', 'kt3']"], 'docstring': 'Wavefunction method. See predicates for valid methods. ``hf``,\n``hartreefock`` and ``hartree-fock`` all mean the same thing, while ``lda``\nis an alias for ``svwn5``. You can set a non-standard DFT functional\n(e.g. varying the amount of exact exchange) by choosing ``dft`` and\nspecifing the functional(s) in the ``DFT`` section below.\n'}, {'name': 'restricted', 'type': 'bool', 'default': True, 'docstring': 'Use spin restricted wavefunction.\n'}]}, {'name': 'DFT', 'docstring': 'Define the exchange-correlation functional in case of DFT.\n', 'keywords': [{'name': 'density_cutoff', 'type': 'float', 'default': 0.0, 'docstring': 'Hard cutoff for passing density values to XCFun.\n'}, {'name': 'functionals', 'type': 'str', 'default': ' ', 'docstring': 'List of density functionals with numerical coefficient. E.g. for PBE0\n``EXX 0.25``, ``PBEX 0.75``, ``PBEC 1.0``, see XCFun\ndocumentation <https://xcfun.readthedocs.io/>_.\n'}, {'name': 'spin', 'type': 'bool', 'default': "not(user['WaveFunction']['restricted'])", 'docstring': 'Use spin separated density functionals.\n'}]}, {'name': 'Properties', 'docstring': 'Provide a list of properties to compute (total SCF energy and orbital\nenergies are always computed).\n', 'keywords': [{'name': 'dipole_moment', 'type': 'bool', 'default': False, 'docstring': 'Compute dipole moment.\n'}, {'name': 'quadrupole_moment', 'type': 'bool', 'default': False, 'docstring': 'Compute quadrupole moment. Note: Gauge origin dependent, should be\nused with ``translate = true`` in Molecule.\n'}, {'name': 'polarizability', 'type': 'bool', 'default': False, 'docstring': 'Compute polarizability tensor.\n'}, {'name': 'magnetizability', 'type': 'bool', 'default': False, 'docstring': 'Compute magnetizability tensor.\n'}, {'name': 'nmr_shielding', 'type': 'bool', 'default': False, 'docstring': 'Compute NMR shielding tensor.\n'}, {'name': 'plot_density', 'type': 'bool', 'default': False, 'docstring': 'Plot converged electron density.\n'}, {'name': 'plot_orbitals', 'type': 'List[int]', 'default': [], 'docstring': 'Plot converged molecular orbitals from list of indices, negative index\nplots all orbitals.\n'}]}, {'name': 'ExternalFields', 'docstring': 'Define external electromagnetic fields.\n', 'keywords': [{'name': 'electric_field', 'type': 'List[float]', 'default': [], 'predicates': ['len(value) == 0 or len(value) == 3'], 'docstring': 'Strength of external electric field.\n'}]}, {'name': 'Polarizability', 'docstring': 'Give details regarding the polarizability calculation.\n', 'keywords': [{'name': 'frequency', 'type': 'List[float]', 'default': [0.0], 'docstring': 'List of external field frequencies.\n'}]}, {'name': 'NMRShielding', 'docstring': 'Give details regarding the NMR shileding calculation.\n', 'keywords': [{'name': 'nuclear_specific', 'type': 'bool', 'default': False, 'docstring': 'Use nuclear specific perturbation operator (h_m_pso).\n'}, {'name': 'nucleus_k', 'type': 'List[int]', 'default': [-1], 'docstring': 'List of nuclei to compute. Negative value computes all nuclei.\n'}]}, {'name': 'Files', 'docstring': 'Defines file paths used for program input/output.\nNote: all paths must be given in quotes if they contain slashes\n"path/to/file".\n', 'keywords': [{'name': 'guess_basis', 'type': 'str', 'default': 'initial_guess/mrchem.bas', 'docstring': 'File name for GTO basis set, used with ``gto`` guess.\n'}, {'name': 'guess_gto_p', 'type': 'str', 'default': 'initial_guess/mrchem.mop', 'docstring': 'File name for paired orbitals, used with ``gto`` guess.\n'}, {'name': 'guess_gto_a', 'type': 'str', 'default': 'initial_guess/mrchem.moa', 'docstring': 'File name for alpha orbitals, used with ``gto`` guess.\n'}, {'name': 'guess_gto_b', 'type': 'str', 'default': 'initial_guess/mrchem.mob', 'docstring': 'File name for beta orbitals, used with ``gto`` guess.\n'}, {'name': 'guess_phi_p', 'type': 'str', 'default': 'initial_guess/phi_p', 'docstring': 'File name for paired orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_phi_a', 'type': 'str', 'default': 'initial_guess/phi_a', 'docstring': 'File name for alpha orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_phi_b', 'type': 'str', 'default': 'initial_guess/phi_b', 'docstring': 'File name for beta orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_x_p', 'type': 'str', 'default': 'initial_guess/X_p', 'docstring': 'File name for paired response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_x_a', 'type': 'str', 'default': 'initial_guess/X_a', 'docstring': 'File name for alpha response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_x_b', 'type': 'str', 'default': 'initial_guess/X_b', 'docstring': 'File name for beta response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_y_p', 'type': 'str', 'default': 'initial_guess/Y_p', 'docstring': 'File name for paired response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_y_a', 'type': 'str', 'default': 'initial_guess/Y_a', 'docstring': 'File name for alpha response orbitals, used with ``mw`` guess.\n'}, {'name': 'guess_y_b', 'type': 'str', 'default': 'initial_guess/Y_b', 'docstring': 'File name for beta response orbitals, used with ``mw`` guess.\n'}]}, {'name': 'SCF', 'docstring': 'Includes parameters related to the ground state SCF orbital optimization.\n', 'keywords': [{'name': 'run', 'type': 'bool', 'default': True, 'docstring': 'Run SCF solver. Otherwise properties are computed on the initial orbitals.\n'}, {'name': 'max_iter', 'type': 'int', 'default': 100, 'docstring': 'Maximum number of SCF iterations.\n'}, {'name': 'kain', 'type': 'int', 'default': 5, 'docstring': 'Length of KAIN iterative history.\n'}, {'name': 'rotation', 'type': 'int', 'default': 0, 'docstring': 'Number of iterations between each diagonalization/localization.\n'}, {'name': 'localize', 'type': 'bool', 'default': False, 'docstring': 'Use canonical or localized orbitals.\n'}, {'name': 'energy_thrs', 'type': 'float', 'default': -1.0, 'docstring': 'Convergence threshold for SCF energy.\n'}, {'name': 'guess_prec', 'type': 'float', 'default': 0.001, 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in construction of initial guess.\n'}, {'name': 'start_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, initial value.\n'}, {'name': 'final_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, final value.\n'}, {'name': 'guess_type', 'type': 'str', 'default': 'sad_dz', 'predicates': ["value.lower() in ['mw', 'chk', 'gto', 'core_sz', 'core_dz', 'core_tz', 'core_qz', 'sad_sz', 'sad_dz', 'sad_tz', 'sad_qz']"], 'docstring': 'Type of initial guess for ground state orbitals.\n``chk`` restarts a previous calculation which was dumped using the\n``write_checkpoint`` keyword. This will load MRA and electron spin\nconfiguration directly from the checkpoint files, which are thus\nrequired to be identical in the two calculations.\n``mw`` will start from final orbitals in a previous calculation written\nusing the ``write_orbitals`` keyword. The orbitals will be re-projected\ninto the new computational setup, which means that the electron spin\nconfiguration and MRA can be different in the two calculations.\n``gto`` reads precomputed GTO orbitals (requires extra non-standard\ninput files for basis set and MO coefficients).\n``core`` and ``sad`` will diagonalize the Fock matrix in the given AO\nbasis (SZ, DZ, TZ or QZ) using a Core or Superposition of Atomic\nDensities Hamiltonian, respectively.\n'}, {'name': 'write_checkpoint', 'type': 'bool', 'default': False, 'docstring': 'Write orbitals to disk in each iteration, file name\n``<path_checkpoint>/phi_scf_idx_<0..N>``. Can be used as ``chk`` initial\nguess in subsequent calculations. Note: must be given in quotes if\nthere are slashes in the path "path/to/checkpoint".\n'}, {'name': 'path_checkpoint', 'type': 'str', 'default': 'checkpoint', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to checkpoint files during SCF, used with ``write_checkpoint``\nand ``chk`` guess.\n'}, {'name': 'write_orbitals', 'type': 'bool', 'default': False, 'docstring': 'Write final orbitals to disk, file name\n``<path_orbitals>/phi_<p/a/b>_scf_idx_<0..Np/Na/Nb>``.\nCan be used as ``mw`` initial guess in subsequent calculations.\n'}, {'name': 'path_orbitals', 'type': 'str', 'default': 'orbitals', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to where converged orbitals will be written in connection with\nthe ``write_orbitals`` keyword. Note: must be given in quotes if\nthere are slashes in the path "path/to/orbitals".\n'}, {'name': 'orbital_thrs', 'type': 'float', 'default': "10 * user['world_prec']", 'docstring': 'Convergence threshold for orbital residuals.\n'}]}, {'name': 'Response', 'docstring': 'Includes parameters related to the response SCF optimization.\n', 'keywords': [{'name': 'run', 'type': 'List[bool]', 'default': [True, True, True], 'docstring': 'In which Cartesian directions to run response solver.\n'}, {'name': 'max_iter', 'type': 'int', 'default': 100, 'docstring': 'Maximum number of response iterations.\n'}, {'name': 'kain', 'type': 'int', 'default': 5, 'docstring': 'Length of KAIN iterative history.\n'}, {'name': 'property_thrs', 'type': 'float', 'default': -1.0, 'docstring': 'Convergence threshold for symmetric property. Symmetric meaning the\nproperty computed from the same operator as the response purturbation,\ne.g. for external magnetic field the symmetric property corresponds to\nthe magnetizability (NMR shielding in non-symmetric, since one of the\noperators is external magnetic field, while the other is nuclear\nmagnetic moment).\n'}, {'name': 'start_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, initial value.\n'}, {'name': 'final_prec', 'type': 'float', 'default': -1.0, 'docstring': 'Incremental precision in SCF iterations, final value.\n'}, {'name': 'guess_prec', 'type': 'float', 'default': 0.001, 'predicates': ['1.0e-10 < value < 1.0'], 'docstring': 'Precision parameter used in construction of initial guess.\n'}, {'name': 'guess_type', 'type': 'str', 'default': 'none', 'predicates': ["value.lower() in ['none', 'chk', 'mw']"], 'docstring': 'Type of initial guess for response.\n``none`` will start from a zero guess for the response functions.\n``chk`` restarts a previous calculation which was dumped using the\n``write_checkpoint`` keyword.\n``mw`` will start from final orbitals in a previous calculation written\nusing the ``write_orbitals`` keyword. The orbitals will be re-projected\ninto the new computational setup.\n'}, {'name': 'write_checkpoint', 'type': 'bool', 'default': False, 'docstring': 'Write perturbed orbitals to disk in each iteration, file name\n``<path_checkpoint>/<X/Y>_rsp_<direction>_idx_<0..N>``. Can be used as ``chk``\ninitial guess in subsequent calculations.\n'}, {'name': 'path_checkpoint', 'type': 'str', 'default': 'checkpoint', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to checkpoint files during SCF, used with ``write_checkpoint``\nand ``chk`` guess.\n'}, {'name': 'write_orbitals', 'type': 'bool', 'default': False, 'docstring': 'Write final perturbed orbitals to disk, file name\n``<path_orbitals>/<X/Y>_<p/a/b>_rsp_<direction>_idx_<0..Np/Na/Nb>``.\nCan be used as ``mw`` initial guess in subsequent calculations.\n'}, {'name': 'path_orbitals', 'type': 'str', 'default': 'orbitals', 'predicates': ["value[-1] != '/'"], 'docstring': 'Path to where converged orbitals will be written in connection with\nthe ``write_orbitals`` keyword.\n'}, {'name': 'orbital_thrs', 'type': 'float', 'default': "10 * user['world_prec']", 'docstring': 'Convergence threshold for orbital residuals.\n'}, {'name': 'localize', 'type': 'bool', 'default': "user['SCF']['localize']", 'docstring': 'Use canonical or localized unperturbed orbitals.\n'}]}]}

    if outfile is not None:
        outfile = path_resolver(outfile)

    return validate_from_dicts(ir=ir, template=stencil, fr_file=outfile)
