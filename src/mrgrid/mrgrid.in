#!@PYTHON_EXECUTABLE@
# -*- coding: utf-8 -*-
# vim:filetype=python:
#
# Written by Jonas Juselius <jonas.juselius@chem.uit.no>
# University of TromsÃ¸, 2008
#

ON=1
OFF=0

executable="@MRGRID_EXECUTABLE@"
debug=@MRCHEM_DRIVER_DEBUG@
printlevel=0
dryrun=False
version="@PROJECT_VERSION@"

import sys, re, optparse, os, string, subprocess, tempfile
from copy import deepcopy

sys.path.append("@CMAKE_INSTALL_PREFIX@/@PYTHON_SITE_INSTALL_DIR@")
import getkw

def main():
    global topsect, debug, executable, printlevel, dryrun

    if debug == ON:
        debug = True
    else:
        debug = False

    valid_keywords = setup_keywords()
    printlevel = int(valid_keywords.getkw('printlevel')[0])
    inpfil = parse_cmdline(valid_keywords)

    if printlevel > 1:
        print "Starting " + sys.argv[0]

    if inpfil is None:
        inpfil = "mrgrid.inp"

    input=getkw.GetkwParser()
    inkw=input.parseFile(inpfil)
    inkw.sanitize(valid_keywords)
    topsect=inkw.get_topsect()
    inkw.run_callbacks(valid_keywords)

    if dryrun:
        xfile='@' + inpfil
        fd=open(xfile,'w')
        print >> fd, inkw.top
        fd.close()
    else:
        with tempfile.TemporaryFile(mode='w+r') as fd:
            fd.write(str(inkw.top))
            fd.seek(0)
            p = subprocess.Popen(executable, stdin=fd)
            sts = os.waitpid(p.pid, 0)[1]
            fd.close()

def parse_cmdline(valid_keywords):
    global debug, executable, printlevel, dryrun
    usage="usage: %prog [options] [config] inpfile"
    cmdln=optparse.OptionParser(usage=usage,
            version="%prog {0}".format(version))
    cmdln.add_option('-D','--dryrun', action='store_true', dest='dryrun',
            default=False, help='Only process input')
    cmdln.add_option('-d','--debug', action='store_true', dest='debug',
            default=False, help='debug')
    cmdln.add_option('-p','--print', action='store', dest='printlevel',
            help='print level')
    cmdln.add_option('-x','--executable', action='store', dest='executable',
            help='set executable name')
    (opts, args)=cmdln.parse_args()

    if opts.executable:
        executable = opts.executable

    if opts.dryrun:
        dryrun=opts.dryrun

    if opts.printlevel:
        printlevel=int(opts.printlevel)
        valid_keywords.setkw('printlevel', printlevel)

    if opts.debug == True:
        debug=opts.debug
        printlevel = 1

    if (len(args) == 0):
        inpfil=None
    elif (len(args) == 1):
        inpfil=args[0]
    else:
        cmdln.error('incorrect number of files')
        sys.exit(0)
    return inpfil

def setup_keywords():
    top=getkw.Section('toplevel', callback=verify_top)
    top.set_status(True)
    top.add_kw('order',				'INT')
    top.add_kw('rel_prec',			'DBL', 1.0e-4)
    top.add_kw('uniform',			'INT', 0)
    top.add_kw('max_depth',			'INT', 20)
    top.add_kw('wavelet',			'STR', 'Interpolating')
    top.add_kw('printlevel',			'INT', 0)
    top.add_kw('teletype',			'BOOL', False)

    world=getkw.Section('World')
    world.add_kw('scale',			'INT', 0)
    world.add_kw('boxes',			'INT_ARRAY', [1, 1, 1])
    world.add_kw('translation',			'INT_ARRAY', [0, 0, 0])
    world.add_kw('origin',			'DBL_ARRAY', [0.0, 0.0, 0.0])
    top.add_sect(world)

    molecule=getkw.Section('Molecule')
    molecule.add_kw('xyz_file',			'STR', 'mrchem.xyz')
    molecule.add_kw('basis_file',	    	'STR', 'mrchem.bas')
    molecule.add_kw('dens_file',	    	'STR', 'mrchem.dens')
    top.add_sect(molecule)
    return top

def verify_top(top):
    wavelet=top.get('wavelet')
    wlet=wavelet.get()
    if re.match('legen.*', wlet, re.I):
        wavelet.set("L")
    elif re.match('inter.*', wlet, re.I):
        wavelet.set("I")
    else:
        print "Invalid wavelet type: ", wavelet
        sys.exit(1)

if __name__ == '__main__':
    main()

