#!/usr/bin/env python

#
# MRChem, a numerical real-space code for molecular electronic structure
# calculations within the self-consistent field (SCF) approximations of quantum
# chemistry (Hartree-Fock and Density Functional Theory).
# Copyright (C) 2019 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
#
# This file is part of MRChem.
#
# MRChem is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# MRChem is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
#
# For information on the complete list of contributors to MRChem, see:
# <https://mrchem.readthedocs.io/>
#

import json
import math
import optparse
import os
import re
import subprocess
import sys
import tempfile
from io import StringIO
from pathlib import Path

# FIXME This will pick up modules when installed
sys.path.append("@CMAKE_INSTALL_PREFIX@/@PYTHON_SITE_INSTALL_DIR@")
sys.path.append('@PROJECT_SOURCE_DIR@/src/chemistry')

from parselglossy.grammars import getkw
from parselglossy.exceptions import SpecificationError, ValidationError
from parselglossy.read_yaml import read_yaml_file
from parselglossy.utils import JSONDict
from parselglossy.validate import check_predicates_node, validate_node


def main():
    this_path = Path(__file__).parent

    # Parse command line
    executable, dryrun, printlevel, inp_file_cmd = parse_cmdline()

    input_file = this_path / inp_file_cmd
    user_dict = read_getkw_file(input_file)

    template_file = '@PROJECT_SOURCE_DIR@/src/input/template.yml'
    template_dict = read_yaml_file(template_file)

    # checks everything except predicates
    user_dict = validate_node(user_dict, template_dict)

    # now that all keywords have some value, we can check predicates
    check_predicates_node(user_dict, user_dict, template_dict)

    # now that all keywords have sensible values,
    # we can translate user input into program input
    program_dict = translate_input(user_dict)

    inp_name, ext_ext = os.path.splitext(inp_file_cmd)
    xfile = inp_name + '.json'
    with open(xfile, 'w') as fd:
        fd.write(json.dumps(program_dict, indent=2))

    if not dryrun:
        cmd = executable + ' ' + xfile
        p = subprocess.call(cmd, shell=True)
        sts = os.waitpid(p.pid, 0)[1]

def read_getkw_file(file_name: Path) -> JSONDict:
    contents = ''
    with file_name.open('r') as f:
        contents = f.read()
    grammar = getkw.grammar()
    return grammar.parseString(contents.lower()).asDict()

def parse_cmdline():
    usage = "usage: %prog [options] [config] inp_file"
    version = "0.0.1"
    cmdln = optparse.OptionParser(
        usage=usage, version="%prog {0}".format(version))
    cmdln.add_option(
        '-D',
        '--dryrun',
        action='store_true',
        dest='dryrun',
        default=False,
        help='Only process input')
    cmdln.add_option(
        '-p',
        '--print',
        action='store',
        dest='printlevel',
        type='int',
        default=0,
        help='print level')
    cmdln.add_option(
        '-x',
        '--executable',
        action='store',
        dest='executable',
        type='string',
        default='/home/stig/src/mrchem-stig/install-json/bin/mrchem.x',
        help='set executable name')

    opts, args = cmdln.parse_args()

    executable = opts.executable
    dryrun = opts.dryrun
    printlevel = int(opts.printlevel)

    if (len(args) == 0):
        cmdln.error('Not input file passed!')
        sys.exit(0)
    elif (len(args) == 1):
        inp_file = args[0]
    else:
        cmdln.error('incorrect number of files')
        sys.exit(0)

    return executable, dryrun, printlevel, inp_file

def translate_input(user_dict):
  program_dict = {}
  write_mpi(program_dict, user_dict);
  write_mra(program_dict, user_dict);
  write_printer(program_dict, user_dict);
  write_molecule(program_dict, user_dict);
  write_initial_guess(program_dict, user_dict);
  write_scf_calculation(program_dict, user_dict);
  #write_rsp_calculations(program_dict, user_dict);

  return program_dict

def write_mpi(program_dict, user_dict):
  program_dict["mpi"] = {
    "numerically_exact": user_dict["mpi"]["numerically_exact"],
    "shared_memory_size": user_dict["mpi"]["shared_memory_size"]
  }

def write_mra(program_dict, user_dict):
  program_dict["mra"] = {
    "basis_type": user_dict["mra"]["basis_type"][0],
    "order": user_dict["mra"]["order"],
    "boxes": user_dict["mra"]["boxes"],
    "corner": user_dict["mra"]["corner"],
    "min_scale": user_dict["mra"]["min_scale"],
    "max_scale": user_dict["mra"]["max_scale"],
    "scaling_factor": [1.0, 1.0, 1.0]
  }

def write_printer(program_dict, user_dict):
  program_dict["printer"] = {
    "filename": "mrchem",
    "printprec": 15,
    "printlevel": user_dict["printlevel"],
    "teletype": user_dict["teletype"]
  }

def write_molecule(program_dict, user_dict):
  AA = 1.0
  if user_dict["molecule"]["angstrom"]:
      AA = 1.889725989
  coords_raw = user_dict["molecule"]["coords"]
  coords_dict = []
  for line in coords_raw.split('\n'):
    sp = line.split()
    if len(sp) > 0:
      atom = sp[0].lower()
      x_a, y_a, z_a = list(map(float, sp[1:]))
      xyz_b = [AA * x_a, AA * y_a, AA * z_a]
      coords_dict.append({
        "atom": atom,
        "xyz": xyz_b
      })

  program_dict["molecule"] = {
    "charge": user_dict["molecule"]["charge"],
    "multiplicity": user_dict["molecule"]["multiplicity"],
    "angstrom": False,
    "coords": coords_dict
  }


def write_initial_guess(program_dict, user_dict):
  guess_str = user_dict["scf"]["initial_guess"]
  method = guess_str.split('_')[0]
  zeta_str = guess_str.split('_')[1]
  if zeta_str == 'sz':
    zeta = 1
  elif zeta_str == 'dz':
    zeta = 2
  elif zeta_str == 'tz':
    zeta = 3
  elif zeta_str == 'qz':
    zeta = 4
  else:
    print("Invalid zeta:" + guess_suffix)

  program_dict["initial_guess"] = {
    "guess_prec": user_dict["rel_prec"],
    "restricted": user_dict["wavefunction"]["restricted"],
    "method": method,
    "zeta": zeta,
    "start_orbitals": "orbitals/phi",
    "final_orbitals": "orbitals/phi",
    "write_orbitals": False
  }

def write_scf_calculation(program_dict, user_dict):
  scf_dict = {
    "scf_prec": user_dict["rel_prec"],
    "final_orbitals": "orbitals/phi",
    "write_orbitals": user_dict["scf"]["write_orbitals"],
  }
  prop_dict = {
   "dipole_moment": {
      "setup_prec": user_dict["rel_prec"],
      "origin": user_dict["mra"]["gauge_origin"]
    }
  }
  if user_dict["properties"]["dipole_moment"]:
    scf_dict["properties"] = prop_dict

  if user_dict["scf"]["run"]:
    scf_dict["orbital_solver"]: {
      "kain": user_dict["scf"]["kain"],
      "max_iter": user_dict["scf"]["max_iter"],
      "rotation": user_dict["scf"]["rotation"],
      "canonical": user_dict["scf"]["canonical"],
      "start_prec": user_dict["scf"]["orbital_prec"][0],
      "final_prec": user_dict["scf"]["orbital_prec"][1],
      "orbital_thrs": user_dict["scf"]["orbital_thrs"],
      "property_thrs": user_dict["scf"]["property_thrs"]
    }

  fock_dict = {
    "kinetic_operator": {
      "derivative": user_dict["derivatives"]["kinetic"]
    },
    "nuclear_operator": {
      "proj_prec": user_dict["nuc_prec"],
      "smooth_prec": user_dict["nuc_prec"],
      "shared_memory": user_dict["mpi"]["share_nuclear_potential"]
    }
  }
  if (user_dict["wavefunction"]["method"] == "hartree" or
      user_dict["wavefunction"]["method"] == "hf" or
      user_dict["wavefunction"]["method"] == "dft"):
    fock_dict["coulomb_operator"] = {
      "poisson_prec": user_dict["rel_prec"],
      "shared_memory": user_dict["mpi"]["share_coulomb_potential"]
    }
  if user_dict["wavefunction"]["method"] == "hf":
    fock_dict["exchange_operator"] = {
      "poisson_prec": user_dict["rel_prec"]
    }


  if user_dict["wavefunction"]["method"] == "dft":
    func_raw = user_dict["dft"]["functionals"]
    func_dict = []
    exx = False
    for line in func_raw.split('\n'):
      sp = line.split()
      if len(sp) > 0:
        func = sp[0].lower()
        coef = [1.0]
        if len(sp) > 1:
          coef = list(map(float, sp[1:]))
        func_dict.append({
          "name": func,
          "coef": coef[0]
        })
        if func == "exx":
          exx = True
    fock_dict["xc_operator"] = {
      "grid_prec": user_dict["rel_prec"],
      "shared_memory": user_dict["mpi"]["share_xc_potential"],
      "xc_functional": {
        "spin": user_dict["dft"]["spin"],
        "gamma": user_dict["dft"]["use_gamma"],
        "cutoff": user_dict["dft"]["density_cutoff"],
        "derivative": user_dict["derivatives"]["dft"],
        "functionals": func_dict
      }
    }
    if exx:
      fock_dict["exchange_operator"] = {
        "poisson_prec": user_dict["rel_prec"]
      }

  scf_dict["fock_operator"] = fock_dict
  program_dict["scf_calculation"] = scf_dict

# Estimate total energy of a moleucule as the sum of the nuclear charges
# to the power Z^(5/2). This is to get an order of magnitude estimate that
# is used to set the precision parameter in mrchem in case of abs_prec.
def estimate_energy(coords):
    est_en = 0.0
    for line in coords:
        sp = line.split()
        elm = sp[0].lower()
        Z = PT[elm].Z
        est_en += pow(Z, 2.5)
    return est_en


if __name__ == '__main__':
    main()
